# 二、Ihome项目实战第一部分
## 1.1 静态资源路径设置

现在运行一下这个项目bee run,然后打开localhost:8080

现在来说一下什么是静态页面处理？

这个ihome项目源码https://github.com/aceld/ihome_go_2，下载下来就可以

先把里面的static目录下的所有资源放到我们新项目loveHome的static文件夹里。备用

然后我们访问一下网站的图片。看一下能不能打开

http://localhost:8080/static/images/home01.jpg

可以打开，因为我们的图片放在了静态资源库下面，如果我们把home01.jpg放在网站根目录下，是不能访问的。因为网站静态资源库是设定的，不是你想放哪就放哪。beego静态路径默认文件夹是static文件夹。其它地方访问不到。

如果想指定路径访问静态资源，需要在main.go里添加下面代码：

```go
beego.SetStaticPath("download1","down")
```

第一个参数是映射的别名，第二个参数是映射到哪个文件夹，设置好后重启服务器就能访问到down下的图片

http://localhost:8080/download1/home01.jpg

如果我们路径访问down/home01.jpg也是访问不到的。

## 1.2 开发环境搭建

项目资源最好是放到github上。这个github是很重要的。一般面试的时候，如果github上有一些自己做的项目的话。是个加分项。

好了。我们这次做的项目是一个手机端的合租网项目。项目详细内容请参考项目大纲。
```
项目模块
        用户模块
        房屋模块
        订单模块

    具体需求
        1.主页
            最多5个房屋logo图片展示，点击可跳转至房屋详情页面
            提供登录/注册入口，登陆后显示用户名,点击可跳转至个人中心
            用户可以选择城区，入住时间，离开时间等条件进行搜索
            城区的区域信息需要动态加载 
        2.注册
            用户账号默认为手机号
            图片验证码正确后才能发送短信验证码
            短信验证码每60秒可发送一次
            每隔条件出错时又响应错误提示 
        3.登录
            用手机号与密码登陆
            错误时有响应提示 
        4.房屋列表页
            可根据入住时间，区域进行筛选，并可进行排序
            房屋信息分页加载
            区域信息动态加载
            筛选条件更新后，页面立即更新 
        5.房屋详情页
            需展示的详细信息参考设计图
            提供预定入口
            若是房东本人查看房屋信息时，预定入口不显示 
        6.房屋预定
            由用户确定入住时间
            根据用户确定的入住时间实时显示合计天数与总金额 
        7.个人主页
            显示个人头像，手机号，用户名（用户名未设置时为用户手机号）
            提供需改个人信息的入口
            提供做为房客下单的查询入口
            提供成为房东所需实名认证的入口
            提供做为房东发布房屋信息的入口
            提供作为房东查询客户订单的入口
            提供退出的入口 
        8.个人信息修改
            可以修改个人头像
            可以修改用户名
            登陆手机号不能修改
            上传头像与用户名分开保存
            上传新头像后页面立即显示新头像 
        9.我的订单（房客）
            按时间倒序显示订单信息
            订单完成后提供平价功能
            已评价的订单能看到评价信息
            被拒绝的订单能看到拒单信息 
        10.实名认证
            实名认证只能进行一次
            提交信息后再次进入后，只能查看信息,不能修改
            认证信息包含姓名与身份证号 
        11.我的房源
            未实名认证的用户不能发布新房源信息,需 引导到实名认证页面
            按时间倒序显示已经发布的房屋信息
            点击房屋可进入详情页面
            对实名认证的用户提供发布新房屋的功能 
        12.发布新房源
            需要用户填写全部房屋信息
            房屋的文字信息与图片分开操作 
        13.客户订单（房东）
            按时间倒序显示用户下的订单
            对于新订单提供接单与拒单的功能
            拒单必须填写拒单原因
            若客户进行了订单评价，需显示 
        14.退出
            提供退出功能
```
我们可以演示一下，下图就是我们的项目效果。具体的功能我就不演示了。占用太多图片，直接写代码吧

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180617/lLK4CABJ8b.png?imageslim)

打开方式，可以在谷歌浏览器中以手机APP方式打开。方法是：

打开开发者工具，或按F12，点

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180617/BHBec18bfg.png?imageslim)

然后点击工具最左上角的小手机图标，就可以看到切换效果。本来是PC的网页瞬间变成手机端效果。

还可以切换手机。

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180617/8Ieadaemfc.png?imageslim)

这里边有各种手机平板选项，可以自己选。

### 1.2.1 创建项目

我们先创建一个新项目bee new loveHome

2018/06/17 17:22:10 INFO     ▶ 0001 Creating application...
        create   D:\gopath\src\loveHome\
        create   D:\gopath\src\loveHome\conf\
        create   D:\gopath\src\loveHome\controllers\
        create   D:\gopath\src\loveHome\models\
        create   D:\gopath\src\loveHome\routers\
        create   D:\gopath\src\loveHome\tests\
        create   D:\gopath\src\loveHome\static\
        create   D:\gopath\src\loveHome\static\js\
        create   D:\gopath\src\loveHome\static\css\
        create   D:\gopath\src\loveHome\static\img\
        create   D:\gopath\src\loveHome\views\
        create   D:\gopath\src\loveHome\conf\app.conf
        create   D:\gopath\src\loveHome\controllers\default.go
        create   D:\gopath\src\loveHome\views\index.tpl
        create   D:\gopath\src\loveHome\routers\router.go
        create   D:\gopath\src\loveHome\tests\default_test.go
        create   D:\gopath\src\loveHome\main.go
2018/06/17 17:22:11 SUCCESS  ▶ 0002 New application successfully created!

### 1.2.2 github上创建项目

创建好后，创建一下github帐号。用来管理项目。

https://github.com/login

新建一个项目名字 loveHome

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180617/Hgk257jkmg.png?imageslim)

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180617/Bb4D66d4K8.png?imageslim)



注意，创建README这个不要选，如果现在创建一个项目，并选了这个，会自动生成一个README

这样的话远程创建和本地仓库就不一样了。远程仓库上有README，而本地仓库没有。如果想一样就pull一下。把远程创建pull下来。如果pull的话就把本地仓库有些东西覆盖掉了。所以。避免麻烦，直接不要README了。

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180617/ed1h34dg9b.png?imageslim)

创建好了后，我们现在把本地的代码上传到github上

### 1.2.3 初始化本地仓库生成.git

在本地项目目录下git init 初始化空的git版本库,就是在本地项目目录下创建.git目录

D:\gopath\src\loveHome>git init
Initialized empty Git repository in D:/gopath/src/loveHome/.git/

### 1.2.4 添加README.md

然后我们在项目目录下创建一个README.md

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180617/cJGlBAlIgd.png?imageslim)

写上内容。

### 1.2.5 代码和远程仓库关联

现在我们将本地代码和远程仓库关联。命令如下：

```
git remote add origin https://github.com/hedianbin/loveHome.git
```

### 1.2.6 查看本地仓库状态

看一下本地仓库的状态,如果没有提交的都是红色的

git status

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180617/Jka76g0G7c.png?imageslim)

### 1.2.7 导入静态资源

把前端给的静态资源文件放到static目录下

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180617/E6CkmiEL12.png?imageslim)

### 1.2.8 添加要上传的文件

好了。现在把本地库的都上传到github上。先把要上传的文件和文件夹添加到本地库中

git add README.md
git add conf/
git add controllers/
git add main.go
git add routers/
git add static/
git add views/

添加的时候如果出现下面信息，不用管。正常的

warning: LF will be replaced by CRLF in routers/router.go.
The file will have its original line endings in your working directory.

### 1.2.9 写commit日志

```
git commit -m "爱家合租网项目20180617更新"
```
![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180617/Gef6B03kFI.png?imageslim)

### 1.2.10 上传代码到github

```
git push -u origin master
```

正常情况下会出现上传进度

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180617/k3EcELe9Bi.png?imageslim)



但是我上传时候出错了

D:\gopath\src\loveHome>git push -u origin master
error: src refspec master does not match any.
error: failed to push some refs to 'https://github.com/hedianbin/loveHome.git'

原因是没有创建主分支master，远程没有匹配上“master”分支  

解决方法：在上传之前先上传一个文本，比如readme.txt文件，github给你自动创建一个master分支 

因为我们之前git add了好多文件，所以我们先不上传这些文件，把上传状态取消

git reset

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180617/E39k166B03.png?imageslim)

我们现在先上传README.md文件

步骤：（开始前把之前创建的.git文件删除，关闭远程连接） 

1、文件下创建一个README.md文件,并写入内容；

2、初始化本地仓库:git init

3、设置github邮箱和用户名

git config --global user.email "[4778141@qq.com](mailto:4778141@qq.com)"

git config --global user.name "hedianbin" 

4、使用命令： git add README.md

5、添加备注： git commit -m "爱家合租网项目20180617更新"

6、重新创建连接： git remote add origin https://github.com/hedianbin/loveHome.git

7、提交添加的README.md文件： git push -u origin master   之后可以看到www.github.com中已经有了一个主分支。 

上传成功后，到github上loveHome仓库中就能看到我们上传的项目。

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180617/HcKA7J4d20.png?imageslim)



如果有改动想更新。按以下命令，比如我改动了README.md

git status 改完后的文件会变为红色，即表示有改动，和远程库的不一样

git add README.md 然后添加要上传的文件

git commit -m "爱家租房更新之0618" 添加注释

git push -u origin master 上传文件到远程仓库，到远程仓库上看一下更新成功没？

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180618/GG5DLC89Gl.png?imageslim)

更新成功。

上传好后我们就可以开发了

## 1.3 路径的截取

用goland打开loveHome项目，把项目跑起来bee run

访问网站localhost:8080

现在我们这个项目的默认主页在static/html/index.html，这样访问不符合人性化，

我们不可能让客户每次都输入这么长的网址。他们也记不住 。

那么怎么解决呢。让客户http://localhost:8080/直接就能打开static/html/index.html

用到一个重定向函数。加到main.go里

```go
package main

import (
   _ "loveHome/routers"
   "github.com/astaxie/beego"
   "github.com/astaxie/beego/context"
   "strings"
   "net/http"
)

func main() {
ignoreStaticPath()
   beego.Run()

}

func ignoreStaticPath()  {
   //透明static
   beego.InsertFilter("/",beego.BeforeRouter,TransparentStatic)
   beego.InsertFilter("/*",beego.BeforeRouter,TransparentStatic)
}
func TransparentStatic(ctx *context.Context)  {
   orpath:=ctx.Request.URL.Path
   beego.Debug("request url: ",orpath)
   //如果请求url还有api字段，说明是指令应该取消静态资源路径重定向
   if strings.Index(orpath,"api") >=0{
      return
   }
   http.ServeFile(ctx.ResponseWriter,ctx.Request,"static/html/"+ctx.Request.URL.Path)
}
```

意思是把所有网址，只要是访问/或/*都会执行的是TransparentStatic方法，重定向网址

beego.InsertFilter("/",beego.BeforeRouter,TransparentStatic)
   beego.InsertFilter("/*",beego.BeforeRouter,TransparentStatic)

TransparentStatic方法传进来一个ctx参数，获取当前窗口句柄

orpath:=ctx.Request.URL.Path ，获取当前窗口的路径。

比如我要访问这个网址：http://localhost:8080/index.html

orpath输出的信息为
```
2018/06/18 11:31:13.147 [D][main.go:24] request url:  /index.html
2018/06/18 11:31:13.152 [D] [server.go:2694] ::1 - - [18/Jun/2018 11:31:13] "GET /index.html HTTP/1.1 301 0" 0.005999  Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1

2018/06/18 11:31:13.158 [D] [main.go:24] request url:  /
2018/06/18 11:31:13.165 [D] [server.go:2694] ::1 - - [18/Jun/2018 11:31:13] "GET / HTTP/1.1 200 0" 0.007004  Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1

2018/06/18 11:31:13.361 [D] [main.go:24] request url:  /api/v1.0/session
2018/06/18 11:31:13.369 [D] [server.go:2694] ::1 - - [18/Jun/2018 11:31:13] "GET /api/v1.0/session HTTP/1.1 404 0" 0.008006 http://localhost:8080/ Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1

2018/06/18 11:31:13.370 [D] [main.go:24] request url:  /api/v1.0/areas
2018/06/18 11:31:13.372 [D] [server.go:2694] ::1 - - [18/Jun/2018 11:31:13] "GET /api/v1.0/areas HTTP/1.1 404 0" 0.003002 http://localhost:8080/ Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1

2018/06/18 11:31:13.370 [D] [main.go:24] request url:  /api/v1.0/houses/index
2018/06/18 11:31:13.382 [D] [server.go:2694] ::1 - - [18/Jun/2018 11:31:13] "GET /api/v1.0/houses/index HTTP/1.1 404 0" 0.012010 http://localhost:8080/ Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1

2018/06/18 11:31:13.461 [D] [main.go:24] request url:  /static/plugins/swiper/js/maps/swiper.jquery.min.js.map 
2018/06/18 11:31:13.492 [D] [server.go:2694] ::1 - - [18/Jun/2018 11:31:13] "GET /static/plugins/swiper/js/maps/swiper.jquery.min.js.map HTTP/1.1 404 0" 0.031022  Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1
```

返回的路径是request url:  /index.html。其实原来访问的是应该是static/html/index.html

所以ignoreStaticPath()方法要把原始网址补全

```go
http.ServeFile(ctx.ResponseWriter,ctx.Request,"static/html/"+ctx.Request.URL.Path)
```

好了。现在我们在main主函数的bee.Run()上面调用这个方法ignoreStaticPath()，开启一下服务器。

直接访问localhost:8080/index.html就可以打开网站了。

## 1.4 创建数据库

打开谷歌浏览器的开发者工具F12，打开Network标签，再点All

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180618/7G7hCGigj0.png?imageslim)

会看到一大堆请求。发现有红色的，404，我们所有的项目都是解决红色的内容。

再一下完整项目的页面

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180618/3EjGKGeI0g.png?imageslim)

完整项目，会有注册，登录按钮，然后会有一下滚动图片效果。

我们的没有出来是因为，网页没有加载完，有些/api文件夹下的没加载出来。

我们先把这些解决一下。

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180618/3IKbEJEJIl.png?imageslim)

先定向一条路由。打开\routers\router.go

添加一条路由信息

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180618/G88LjDI4BF.png?imageslim)

```
beego.Router("/api/v1.0/areas", &controllers.MainController{})
```

路由路径改成/api/v1.0/areas

好了。现在我们开始写areas的方法。功能实现在是首页。选择城区。返回的城区的数据

最好把每个方法都创建一个go文件。这样方便管理

我们在controllers下创建一个areas.go

一般开发项目的流程：

现在的互联网公司有两种

外包型：外包公司，客户需求不需要调研，客户只要提出来需要，比如我要做一个淘宝这样的，做一个链家这样的网站。然后客户会给一个模板过来。外包公司就仿照这个模板写就行了。

自研发型：客户发现一个业务。这方面没人去做，决得是个商机。客户就提要求，调研，写设计文档。设计文档分为概要设计和详细设计，概要设计一般用到的软件axure,这个软件很火，比如我要设计一个网站。用这个软件拖拖拽拽就出来了。虽然看起来很丑，就像PS一样，PS是图片拼网站，但这个axure是控件拼网站。一般开发人员用这个软件先设计个网站模型出来，然后来问产品经理。你看看我们的网站功能大概是不是这样，然后大家去协商，开会，开完会。我们会再设计一个详细设计文档，这个文档就复杂，里面会有数据格式，还有一些简单的代码。有的详细设计还会有一个接口。我们去公司一般去实现接口的。就是他给你很多函数，他会告诉你，参数也有了，返回值也有了。就是里面的功能没有写。这个你给我写一下，他也不会和你说的很啰嗦，他只会说，这个业务交给你。

一般一个网站项目制作周期是两到三个月，一到两个月是在设计阶段，开发用一周到二周。开发完之后也会出各种问题。需要后期修改一到两个月，你觉得行了。一测试，还是会有各种问题。所以不是不段测试，不段修改的过程，这段时间经常会和产品经理互怼，你会觉得产品经理设计的不合理，根本不存在，做不出来。但是产品经理不管，我就要这个功能，人家项目里有，我项目里也要有。你必须要给我做，测试是比较怂的行业。没事请测试吃个饭，为什么开发一半是男的测试，一半是女的，男的不好意思和女的怼，一般测试女的比较细心，一测就会测出很多BUG，一堆的BUG。乱七八糟的BUG，啥都能测出来，一般不给你按常理出牌，如果你按正常流程走，注册，登录，发布停下，一般都没问题的是吧，一般我们都会自测一下。而测试员一般不会这么干，她先输网址看看能不能例如，然后乱点，看哪会出问题。另外还有一种叫抗压测试，用一个软件，一直点一直点。一分钟点200遍。看看抗不抗压，目标是把系统搞崩溃了就好了。

一般我们数据库的设计是在第一到两个月阶段，我就要把所有的表结构都要想出来，不是说用到哪插到哪。那就乱了，大家都用一张表，大家都用到哪改到哪，那就完了，乱套了。所以必须要统计事先设计好，然后表中每字段 都会有说明文档，一般情况下不允许私自修改表内容。一般设计人员都会设计到。一般没有的数据也都会通过高级查询获得。

好了，继续说项目

如果我们的请求是这样的

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180618/AEkiLf32I2.png?imageslim)



详细设计一般是这样的

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180618/k6fC459JCB.png?imageslim)

告诉你。如果请求成功了，返回值

请求失败了。返回值
注意：如果你发现某个地方单词写错了。不要自作聪明的给他改正过来。因为这个详细设计是前端和后端的唯一沟通桥梁。就是开发的时候。前端只负责前端，后端只开发后台。测试的时候都是自测。但是你们都自测完了。对接以后，你们发现数据对不上。比如你返回的是data,而前端要的是datta.这样的死活调不出来。全是你的责任。所以不要自作聪明。

如果你发现错误了。你可以和组长题。或广播 。通知错误点。修改设计文档。如果没有改。只能按错的来。不然前后端沟通不一致，导致数据是错的。是你的责任。



![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180618/IaeB76CLHJ.png?imageslim)

上面是业务流程图，怎么去开发，大概流程怎么走

1.路由过来了。请求，地址信息固定的，至少地区保持好多年不变。可以存到数据库里。也可以存到redis里。

介绍一下关系型数据库和非关系型数据库优缺点。

关系型数据库就像mysql这样的。非关系 型数据库像redis

一般什么情况下用关系型数据库，什么情况下用非关系型数据库

redis 一般是存业务逻辑简单的，

>弊端：没办法进行复杂查询。只能进行简单查询key和value,像研究mysql的技术，就光mysql。但是非关系数据库做不到这点。
>优势：效率快
>
>

mysql  数据库复杂查询，数据总变的存这里

像我们这个项目的area 地址，可以存到redis里。因为这个地点很少变。

2.路由过来后，我们从缓存中去获取数据，如果有数据，直接返回地域信息json,结束查询

3.如果缓存中没有数据，会从mysql中查找全部areas数据，

4.然后将数据打包成json字符串存入缓存中。

5.返回areas信息json给前端，然后结束操作

现在缓存中肯定是没有数据的，我们需要先往mysql中插入数据

先创建一个项目数据库，放在models/models.go里，这个目录是专门操作数据库的

>这里特别注意，设置`json:"name"`的时候。json前面千万不要用tab来间隔，一定要用空格，否则json不生效，输出的json还是首字母大写。

分析一下数据表

用户表user

```go
/* 用户 table_name = user */
type User struct {
	Id 				int				`json:"user_id"`					//用户编号
	Name			string			`orm:"size(32);unique" json:"name"`		//用户昵称
	Password_hash	string			`orm:"size(128)" json:"password"`		//用户密码加密的
	Mobile			string			`orm:"size(11)" json:"mobile"`			//手机号
	Real_name		string			`orm:"size(32)" json:"real_name"`		//真实姓名
	Id_card			string			`orm:"size(20)" json:"id_card"`			//身份证号
	Avatar_url		string			`orm:"size(256)" json:"avatar_url"`		//用户头像路径
	Houses			[] *House		`orm:"reverse(many)" json:"houses"`	//用户发布的房屋信息
	Orders			[] *OrderHouse	`orm:"reverse(many)" json:"orders"`		//用户下的订单
}
```
一般用户有关的信息都会存在这，比如以后我们要修改用户信息，也会去修改这张表

房屋信息表House

```go
/* 户层信息 table_name = house */
type House struct {
	Id 				int				`json:"house_id"`				//房屋编号
	User 			*User			`orm:"rel(fk)" json:"user_id"`		//房屋主人的用户编号
	Area 			*Area			`orm:"rel(fk)" json:"area_id"`		//归属地的区域编号
	Title			string			`orm:"size(64)" json:"title"`		//房屋标题
	Price			int				`orm:"default(0)" json:"price"`	//单价，单位：分
	Address 		string			`orm:"size(512)" orm:"default("")" json:"address"` //地址
	Room_count		int				`orm:"default(1)" json:"room_count"`		//房间数目
	Acreage			int				`orm:"default(0)" json:"acreage"`			//房屋总面积
	Unit 			string			`orm:"size(32)" orm:"default("")" json:"unit"`	//房屋单元，如 几室几厅
	Capacity		int				`orm:"default(1)" json:"capacity"`		//房屋容纳的总人数
	Beds			string			`orm:"size(64)"	orm:"default("")" json:"beds"`	//房屋床铺的位置
	Deposit			int				`orm:"default(0)" json:"deposit"`		//押金
	Min_days		int				`orm:"default(1)" json:"min_days"`	//最少入住天数
	Max_days 		int				`orm:"default(0)" json:"max_days"`	//最多住天数 0表示不限制
	Order_count		int				`orm:"default(0)" json:"order_count"`	//预定完成的该房屋的订单数
	Index_image_url	string			`orm:"size(256)" orm:"default("")" json:"index_image_url"`	//房屋主图片路径
	Facilities		[] *Facility	`orm:"reverse(many)" json:"facilities"`		//房屋设施
	Images			[] *HouseImage	`orm:"reverse(many)" json:"img_urls"`		//房屋的图片
	Orders			[] *OrderHouse	`orm:"reverse(many)" json:"orders"`		//房屋的订单
	Ctime			time.Time		`orm:"auto_now_add;type(datetime)" json:"ctime"`
}
```

像一些房屋信息都会存在这里面，比如像链家的每间房屋页面都有房屋属性，就是存在这张表里的。

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180618/5LHkIaHCgi.png?imageslim)

像房屋面积，户型，楼屋，朝向，地址，发布时间，主图，副图等。我们这个也是和链家差不多。大同小异

重点：

 Facilities    [] *Facility   `orm:"reverse(many)" json:"facilities"`    //房屋设施
   Images       [] *HouseImage `orm:"reverse(many)" json:"img_urls"`      //房屋的图片
   Orders       [] *OrderHouse `orm:"reverse(many)" json:"orders"`    //房屋的订单

这三个属性，orm设置了一对多反向关系，即多对一，

**设施和房子的结构关系** 

比如：房屋设施和房屋有什么关系？每个房屋可以有多个设施，一种设施可以被多个房屋所有，比如热水器，好多房屋都可以有热水器，所以这个热水器可以对好多房屋，还有，一个房屋除了有热水器，还可以有桌子，板凳，衣柜等 。应该是多对多的关系 

 Facilities    [] *Facility

House里有Facilities    [] *Facility数组，orm设置为`orm:"reverse(many)"` 每个房屋有多个设施

Facilities里面有Houses  [] *House数组 ,orm设置为`orm:"rel(m2m)"` 有哪些房间有此设施，有可能多个房间都有此设施，所以用多对多关系

**图片和房子的结构关系**

House里有Images       [] *HouseImage 数组，orm设置为多对一关系，`orm:"reverse(many)"`，即，每个房间可以有多张图片

HouseImage里有 House  *House  orm设置为了一对多关系`orm:"rel(fk)"`，每张图片对应一个房子，所以用一对多，因为这个房子的图片不可能给别的房子用吧。

**订单和房子的结构关系** 

House里有Orders       [] *OrderHouse，orm设置为`orm:"reverse(many)"`，多对一关系 ,表示房子会有多张订单。

OrderHouse里有House        *House    orm设置为`orm:"rel(fk)"`，一对多关系 ，每份订单只对应一个房子。

完整数据库代码

```go
package models

import (
	"time"
	"github.com/astaxie/beego/orm"
	_ "github.com/go-sql-driver/mysql"
)

/* 用户 table_name = user */
type User struct {
	Id 				int				`json:"user_id"`							//用户编号
	Name			string			`orm:"size(32);unique" json:"name"`		//用户昵称
	Password_hash	string			`orm:"size(128)" json:"password"`		//用户密码加密的
	Mobile			string			`orm:"size(11)" json:"mobile"`			//手机号
	Real_name		string			`orm:"size(32)" json:"real_name"`		//真实姓名
	Id_card			string			`orm:"size(20)" json:"id_card"`			//身份证号
	Avatar_url		string			`orm:"size(256)" json:"avatar_url"`		//用户头像路径
	Houses			[] *House		`orm:"reverse(many)" json:"houses"`		//用户发布的房屋信息
	Orders			[] *OrderHouse	`orm:"reverse(many)" json:"orders"`		//用户下的订单
}

/* 户层信息 table_name = house */
type House struct {
	Id 				int				`json:"house_id"`				//房屋编号
	User 			*User			`orm:"rel(fk)" json:"user_id"`		//房屋主人的用户编号
	Area 			*Area			`orm:"rel(fk)" json:"area_id"`		//归属地的区域编号
	Title			string			`orm:"size(64)" json:"title"`		//房屋标题
	Price			int				`orm:"default(0)" json:"price"`	//单价，单位：分
	Address 		string			`orm:"size(512)" orm:"default("")" json:"address"` //地址
	Room_count		int				`orm:"default(1)" json:"room_count"`		//房间数目
	Acreage			int				`orm:"default(0)" json:"acreage"`			//房屋总面积
	Unit 			string			`orm:"size(32)" orm:"default("")" json:"unit"`	//房屋单元，如 几室几厅
	Capacity		int				`orm:"default(1)" json:"capacity"`		//房屋容纳的总人数
	Beds			string			`orm:"size(64)"	orm:"default("")" json:"beds"`	//房屋床铺的位置
	Deposit			int				`orm:"default(0)" json:"deposit"`		//押金
	Min_days		int				`orm:"default(1)" json:"min_days"`	//最少入住天数
	Max_days 		int				`orm:"default(0)" json:"max_days"`	//最多住天数 0表示不限制
	Order_count		int				`orm:"default(0)" json:"order_count"`	//预定完成的该房屋的订单数
	Index_image_url	string			`orm:"size(256)" orm:"default("")" json:"index_image_url"`	//房屋主图片路径
	Facilities		[] *Facility	`orm:"reverse(many)" json:"facilities"`		//房屋设施
	Images			[] *HouseImage	`orm:"reverse(many)" json:"img_urls"`		//房屋的图片
	Orders			[] *OrderHouse	`orm:"reverse(many)" json:"orders"`		//房屋的订单
	Ctime			time.Time		`orm:"auto_now_add;type(datetime)" json:"ctime"`
}
//首页最高展示的房屋数量
var HOME_PAGE_MAX_HOUSES int = 5
//房屋列表页面每页显示条目数
var HOUSE_LIST_PAGE_CAPACITY int = 2

/* 区域信息 table_name = area */
type Area struct {
	Id 		int     `json:"aid"`					//区域编号
	Name 	string  `orm:"size(32)" json:"aname"`	//区域名字
}

/* 设施信息 table_name = "facility" */
type Facility struct {
	Id 		int 		`json:"fid"`			//设施编号
	Name 	string		`orm:"size(32)"`		//设施名字
	Houses  [] *House	`orm:"rel(m2m)"`		//都有哪些房屋有此设施
}

/* 房屋图片 table_name = "house_image" */
type HouseImage struct {
	Id 		int		`json:"house_image_id"`			//图片id
	Url 	string	`orm:"size(256)" json:"url"`	//图片url
	House 	*House	`orm:"rel(fk)" json:"house_id"` //图片所属房屋编号
}
/* 订单状态常量 */
const(
	ORDER_STATUS_WAIT_ACCEPT  	= "WAIT_ACCEPT"		//待接单
	ORDER_STATUS_WAIT_PAYMENT  	= "WAIT_PAYMENT"	//待支付
	ORDER_STATUS_PAID  			= "PAID"			//已支付
	ORDER_STATUS_WAIT_COMMENT  	= "COMMENT"			//待评价
	ORDER_STATUS_COMPLETE 	= "COMPLETE"			//已完成
	ORDER_STATUS_CANCELED  	= "CANCELED"			//已取消
	ORDER_STATUS_REJECTED  	= "REJECTED"			//已拒单
)

/*  订单 table_name = order */
type OrderHouse struct {
	Id				int			`json:"order_id"`					//订单编号
	User			*User		`orm:"rel(fk)" json:"user_id"`		//下单的用户编号
	House			*House		`orm:"rel(fk)" json:"house_id"`	//预定的房间编号
	Begin_data		time.Time	`orm:"type(datetime)"`				//预定的起始时间
	End_data		time.Time	`orm:"type(datetime)"`				//预定的结束时间
	Days			int												//预定总天数
	House_price		int												//房屋的单价
	Amount			int												//订单总金额
	Status			string		`orm:"default(WAIT_ACCEPT)"`		//订单状态
	Comment			string		`orm:"size(512)"`					//订单评论
	Ctime			time.Time	`orm:"auto_now_add;type(datetime)" json:"ctime"`	//
}

func init()  {
	// set default database
	orm.RegisterDataBase("default", "mysql", "root:123456@tcp(127.0.0.1:3306)/lovehome?charset=utf8", 30)

	// register model
	orm.RegisterModel(new(User),new(House),new(Area),new(Facility),new(HouseImage),new(OrderHouse))

	// create table
	orm.RunSyncdb("default", false, true)
}
```
数据库结构写好后，我们先来创建一个数据库，注意编码要用utf8

```mysql
create database if not exists lovehome default charset utf8 collate utf8_general_ci;
```

然后我们往数据库里插入一些基础数据

然后我们去写创建数据库的go代码，在models.go里加入下面代码，并修改成自己的数据库信息，

包括 ，用户名，密码，库名，数据库表名

然后orm.RegisterModel里把要添加的表都加进来。

```go
// set default database
	orm.RegisterDataBase("default", "mysql", "root:123456@tcp(127.0.0.1:3306)/lovehome?charset=utf8", 30)

	// register model
	orm.RegisterModel(new(User),new(House),new(Area),new(Facility),new(HouseImage),new(OrderHouse))

	// create table
	orm.RunSyncdb("default", false, true)
```

好了。现在还需要main.go里调用一下models包，否则不能执行。

```
_ "loveHome/models" //包前面 下划线+空格
```
然后bee run一下，发现又出错了
[ORM]2018/06/18 18:17:22 register db `default`, sql: unknown driver "mysql" (forgotten import?)
must have one register DataBase alias named `default`
上面错误代码是因为没有导入mysql驱动包，在models.go里导入一下

```
_ "github.com/go-sql-driver/mysql" //前面下划线不要忘了
```
再次运行bee run，这回成功了，一下子出来一大波创建数据库表的语句

```mysql
create table `user`
    -- --------------------------------------------------
    --  Table Structure for `loveHome/models.User`
    -- --------------------------------------------------
    CREATE TABLE IF NOT EXISTS `user` (
        `id` integer AUTO_INCREMENT NOT NULL PRIMARY KEY,
        `name` varchar(32) NOT NULL DEFAULT ''  UNIQUE,
        `password_hash` varchar(128) NOT NULL DEFAULT '' ,
        `mobile` varchar(11) NOT NULL DEFAULT '' ,
        `real_name` varchar(32) NOT NULL DEFAULT '' ,
        `id_card` varchar(20) NOT NULL DEFAULT '' ,
        `avatar_url` varchar(256) NOT NULL DEFAULT ''
    ) ENGINE=InnoDB;

create table `house`
    -- --------------------------------------------------
    --  Table Structure for `loveHome/models.House`
    -- --------------------------------------------------
    CREATE TABLE IF NOT EXISTS `house` (
        `id` integer AUTO_INCREMENT NOT NULL PRIMARY KEY,
        `user_id` integer NOT NULL,
        `area_id` integer NOT NULL,
        `title` varchar(64) NOT NULL DEFAULT '' ,
        `price` integer NOT NULL DEFAULT 0 ,
        `address` varchar(512) NOT NULL DEFAULT '' ,
        `room_count` integer NOT NULL DEFAULT 1 ,
        `acreage` integer NOT NULL DEFAULT 0 ,
        `unit` varchar(32) NOT NULL DEFAULT '' ,
        `capacity` integer NOT NULL DEFAULT 1 ,
        `beds` varchar(64) NOT NULL DEFAULT '' ,
        `deposit` integer NOT NULL DEFAULT 0 ,
        `min_days` integer NOT NULL DEFAULT 1 ,
        `max_days` integer NOT NULL DEFAULT 0 ,
        `order_count` integer NOT NULL DEFAULT 0 ,
        `index_image_url` varchar(256) NOT NULL DEFAULT '' ,
        `ctime` datetime NOT NULL
    ) ENGINE=InnoDB;

create table `area`
    -- --------------------------------------------------
    --  Table Structure for `loveHome/models.Area`
    -- --------------------------------------------------
    CREATE TABLE IF NOT EXISTS `area` (
        `id` integer AUTO_INCREMENT NOT NULL PRIMARY KEY,
        `name` varchar(32) NOT NULL DEFAULT ''
    ) ENGINE=InnoDB;

create table `facility`
    -- --------------------------------------------------
    --  Table Structure for `loveHome/models.Facility`
    -- --------------------------------------------------
    CREATE TABLE IF NOT EXISTS `facility` (
        `id` integer AUTO_INCREMENT NOT NULL PRIMARY KEY,
        `name` varchar(32) NOT NULL DEFAULT ''
    ) ENGINE=InnoDB;

create table `house_image`
    -- --------------------------------------------------
    --  Table Structure for `loveHome/models.HouseImage`
    -- --------------------------------------------------
    CREATE TABLE IF NOT EXISTS `house_image` (
        `id` integer AUTO_INCREMENT NOT NULL PRIMARY KEY,
        `url` varchar(256) NOT NULL DEFAULT '' ,
        `house_id` integer NOT NULL
    ) ENGINE=InnoDB;
create table `order_house`
    -- --------------------------------------------------                                                          --  Table Structure for `loveHome/models.OrderHouse`
    -- --------------------------------------------------
    CREATE TABLE IF NOT EXISTS `order_house` (                                                                         `id` integer AUTO_INCREMENT NOT NULL PRIMARY KEY,                                                              `user_id` integer NOT NULL,
        `house_id` integer NOT NULL,
        `begin_data` datetime NOT NULL,                                                                                `end_data` datetime NOT NULL,
        `days` integer NOT NULL DEFAULT 0 ,
        `house_price` integer NOT NULL DEFAULT 0 ,                                                                     `amount` integer NOT NULL DEFAULT 0 ,                                                                          `status` varchar(255) NOT NULL DEFAULT 'WAIT_ACCEPT' ,
        `comment` varchar(512) NOT NULL DEFAULT '' ,
        `ctime` datetime NOT NULL                                                                                  ) ENGINE=InnoDB;                                     
create table `facility_houses`
    -- --------------------------------------------------
    --  Table Structure for `loveHome/models.FacilityHouses`
    -- --------------------------------------------------
    CREATE TABLE IF NOT EXISTS `facility_houses` (
        `id` bigint AUTO_INCREMENT NOT NULL PRIMARY KEY,
        `facility_id` integer NOT NULL,
        `house_id` integer NOT NULL
    ) ENGINE=InnoDB;
```

看一下数据库里创建成功了吗

```
mysql> show tables;
+--------------------+
| Tables_in_lovehome |
+--------------------+
| area               |
| facility           |
| facility_houses    |
| house              |
| house_image        |
| order_house        |
| user               |
+--------------------+
7 rows in set (0.00 sec)
```

创建成功了，但是发现多了一张表facility_houses，我们看一下表结构

```
mysql> desc facility_houses;
+-------------+------------+------+-----+---------+----------------+
| Field       | Type       | Null | Key | Default | Extra          |
+-------------+------------+------+-----+---------+----------------+
| id          | bigint(20) | NO   | PRI | NULL    | auto_increment |
| facility_id | int(11)    | NO   |     | NULL    |                |
| house_id    | int(11)    | NO   |     | NULL    |                |
+-------------+------------+------+-----+---------+----------------+
3 rows in set (0.00 sec)
```

里面就三个字段 ，第一个是id，主键自增，第二个是设施id,第三个是房子id.

这就是视图，视图就两张表拼成了一张。就是上面这个表。

## 1.5 导入area数据

接下来,数据库有了,我们现在往里导入一些数据.导入脚本已经给好了

```mysql
INSERT INTO area(name)VALUES("东城区"),("西城区"),("朝阳区"),("海淀区"),("昌平区"),("丰台区"),("房山区"),("通州区"),("顺义区"),("大兴区"),("怀柔区"),("平谷区"),("密云区"),("延庆区"),("石景山区");
INSERT INTO facility(name) VALUES("无线网络"),("热水淋浴"),("空调"),("暖气"),("允许吸烟"),("饮水设备"),("牙具"),("香皂"),("拖鞋"),("手纸"),("毛巾"),("沐浴露、洗发露"),("冰箱"),("洗衣机"),("电梯"),("允许做饭"),("允许带宠物"),("允许聚会"),("门禁系统"),("停车位"),("有线网络"),("电视"),("浴缸"),("吃鸡"),("打台球");
```

直接在mysql命令行下粘贴也可以。还可以用另一种方式，比如我们把这个插入数据的命令保存到项目目录的conf/area.sql里

然后我们退出mysql>exit;

进入到项目目录放置area.sql的文件夹下。我的在D:\gopath\src\loveHome\conf

然后我们在dos执行mysql -uroot -p123456再次登录mysql，这时路径就是上面进入的

进入数据库use lovehome;

然后执行导入命令source area.sql;

```mysql
mysql> source area.sql;
Query OK, 15 rows affected (0.01 sec)
Records: 15  Duplicates: 0  Warnings: 0

Query OK, 25 rows affected (0.01 sec)
Records: 25  Duplicates: 0  Warnings: 0
```

提示影响了多少行数据，就表示插入成功了。

然后看一下插入成功没？

```mysql
mysql> select * from facility;
+----+-----------------------+
| id | name                  |
+----+-----------------------+
|  1 | 无线网络              |
|  2 | 热水淋浴              |
|  3 | 空调                  |
|  4 | 暖气                  |
|  5 | 允许吸烟              |
|  6 | 饮水设备              |
|  7 | 牙具                  |
|  8 | 香皂                  |
|  9 | 拖鞋                  |
| 10 | 手纸                  |
| 11 | 毛巾                  |
| 12 | 沐浴露、洗发露        |
| 13 | 冰箱                  |
| 14 | 洗衣机                |
| 15 | 电梯                  |
| 16 | 允许做饭              |
| 17 | 允许带宠物            |
| 18 | 允许聚会              |
| 19 | 门禁系统              |
| 20 | 停车位                |
| 21 | 有线网络              |
| 22 | 电视                  |
| 23 | 浴缸                  |
| 24 | 吃鸡                  |
| 25 | 打台球                |
+----+-----------------------+
25 rows in set (0.00 sec)
```

```mysql
mysql> select * from area;
+----+--------------+
| id | name         |
+----+--------------+
|  1 | 东城区       |
|  2 | 西城区       |
|  3 | 朝阳区       |
|  4 | 海淀区       |
|  5 | 昌平区       |
|  6 | 丰台区       |
|  7 | 房山区       |
|  8 | 通州区       |
|  9 | 顺义区       |
| 10 | 大兴区       |
| 11 | 怀柔区       |
| 12 | 平谷区       |
| 13 | 密云区       |
| 14 | 延庆区       |
| 15 | 石景山区     |
+----+--------------+
15 rows in set (0.00 sec)
```

有数据。已经正常插入。然后我们就能用这些数据了。

## 1.6 显示area数据

现在我们要实现的功能是从数据库里获取城区

先设计/api/v1.0/areas路由调用的方法名，设置为AreaController

routers/router.go

```go
beego.Router("/api/v1.0/areas", &controllers.AreaController{})
```

然后去写这个方法的实现过程

controllers/area.go

```go
package controllers

import (
   "github.com/astaxie/beego"
)
//结构体名应该和router.go里设置应该一样
type AreaController struct {
   beego.Controller
}
//调用的方法是get:GetArea
func (c *AreaController) GetArea() {
   //.....
}
```

这时我们去修改一下routers/router.go，把路由添加对应的方法get:GetArea

```
beego.Router("/api/v1.0/areas", &controllers.AreaController{},"get:GetArea")
```

然后直接打印看看方法能不能执行成功。

```
func (c *AreaController) GetArea() {
   beego.Info("getarea success") //输出信息
}
```

开启一下服务器bee run，发现areas还是红的。但是这不是错误。

![1529320510582](C:\Users\Administrator\AppData\Local\Temp\1529320510582.png)

![1529320484227](C:\Users\Administrator\AppData\Local\Temp\1529320484227.png)

看上面，状态码Status Code: 500 Internal Server Error,这是页面找到了。有请求了。

但是返回的数据不对，所以出500错误，说明响应成功了。

看一下控制台，有连接成功提示

2018/06/18 19:14:21.082 [I][area.go:12] getarea success

继续开始设计写代码

//从session拿数据

//第一步，从数据库中拿到数据。

//第二步，把拿到的数据打包成json返回给前端。

返回格式是json,前端要啥我们就给返回啥。

```json
返回成功:
{
    "error":0,
    "errmsg":"OK",
    "data":[
        {"aid":1,"aname":"东城区"},
        {"aid":2,"aname":"西城区"},
        {"aid":3,"aname":"通州区"},
        {"aid":4,"aname":"顺义区"},
        //...
    ]
}
返回失败:
{
    "errno":"400x",//状态码
    "errmsg":"状态错误信息"
}
```

我们先从数据库中拿到数据，肯定是用orm，事先导入orm包

```go
"github.com/astaxie/beego/orm"
```

```go
func (c *AreaController) GetArea() {
   beego.Info("getarea success")
   //从session拿数据

   //第一步，从数据中拿到数据。
   area:=models.Area{}
   o:=orm.NewOrm()
   err:=o.Read(&area)
   if err!=nil{
      beego.Info("数据错误")
      //前端要求返回json包
      return
   }

   //第二步，把拿到的数据打包成json返回给前端。

}
```
一般情况下我们返回给前端json格式一般是创建一个结构体

```go
type Area struct {
   errno int
   errmsg string
}
```

然后把这个结构体打包成json返回给前端。

但是一般设计里会有很多相同的返回成功，返回失败，很多都格式相同。

所以如果有多个功能需要返回，我们就需要定义很多个结构体返回数据包，这样很麻烦。代码量也大。

我们可以用GO另外一个特性来实现这个功能。map,看下面代码

```go
//key一般用字符串，value是万能类型interface{}，爱啥是啥。
var resp map[string]interface{}
但是注意，这样是声明map，只声明不初始化是不能往里存数据的
正确写法
resp:=make(map[string]interface{})
因为没初始化所以，获取不到areas的数据
```

然后查询失败返回错误信息可以这样写

```go
if err!=nil{
		beego.Info("数据错误")
		resp["errno"]=4001
		resp["errmsg"]="查询失败"
		return
	}
```

查询成功的话

```go
//查询成功返回数据
resp["errno"]=0
resp["errmsg"]="OK"
resp["data"]=&area //area是结构体。所以要取地址
```

查询完成后，下面就进行第二步。打包数据成json返回给前端。

官方文档已经给了生成json的代码，直接拿来用就可以

https://beego.me/docs/mvc/controller/jsonxml.md

JSON 数据直接输出：

```go
func (this *AddController) Get() {
    mystruct := { ... }
    this.Data["json"] = &mystruct
    this.ServeJSON()
}
```

调用 ServeJSON 之后，会设置 `content-type` 为 `application/json`，然后同时把数据进行 JSON 序列化输出。

我们把最后两行代码拿出来使用

```
  this.Data["json"] = &mystruct
  this.ServeJSON()
```

放到c.Ctx.WriteString(json_str)后面

然后修改一下方法this.为c.

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180618/bjiIi5g6kC.png?imageslim)

要和方法的结构体的参数别名对应上。func (c *AreaController) GetArea() 

但是我们发现，这样写很麻烦，每次返回信息的信息都要这样写一遍。增加了很多重复代码。

我们可以把这样的重复的代码提取出来变成函数重复调用。是个很好的解决方法。

代码如下：

```go
func (this *AreaController) RetData(resp map[string]interface{})  {
   this.Data["json"] = resp
   this.ServeJSON()
}
```

上面的方法属于AreaController结构体的方法，传递的参数是resp，类型是map[string]interface{}，因为我们要把生成好的resp的数据传进来打包成json

现在我们在需要的地方调用就可以了。

c.RetData(resp)

原来下面这两行代码就不需要了

```go
json_str,err:=json.Marshal(resp)
c.Ctx.WriteString(json_str) //返回数据给前端
```

这时候数据就可以返回给前端了。完整代码

```go
func (c *AreaController) GetArea() {
   beego.Info("getarea success")
   resp:=map[string]interface{}
   //从session拿数据

   //第一步，从数据中拿到数据。
   area:=models.Area{}
   o:=orm.NewOrm()
   err:=o.Read(&area)
   //如果没查询到返回的数据
   if err!=nil{
      beego.Info("数据错误")
      resp["errno"]=4001
      resp["errmsg"]="查询失败"
      c.RetData(resp)
      return
   }
   //查询成功返回数据
   resp["errno"]=0
   resp["errmsg"]="OK"
   resp["data"]=&area //area是结构体。所以要取地址

   //第二步，把拿到的数据打包成json返回给前端。
   c.RetData(resp)

}
```

现在跑一下。bee run

发现没有拿到数据，area还是红色的500错误

我们打印一下resp,看看输出结果

```
beego.Info("resp data succee",resp)
```

发现终端显示数据错误

[area.go:29] 数据错误

查到原因了。因为我们要查询的是所有的城区数据，应该有很多条数据，应该放在数据里，刚才我们设置的结构体变量不是数组，需要重新设置

```
area:=models.Area{} //查询单条数据这样用
o:=orm.NewOrm()
err:=o.Read(&area) //只读一条数据
```

重写代码。

```go
//声明并初始化一个数组用来存从数据库中查询到的所有城区数据。用数组
var areas []models.Area
o:=orm.NewOrm()
//查询area表里的全部数据，存到areas缓存数组中，返回的是int64查询的条数，error错误信息
num,err:=o.QueryTable("area").All(&areas)
//如果没查询到返回的数据
if err!=nil{
   beego.Info("数据错误")
   resp["errno"]=4001
   resp["errmsg"]="查询失败"
   c.RetData(resp)
   return
}

```

如果查询成功，但查到的没有数据,即num==0的话，我们也做返回json数据

```go
if num==0{
   resp["errno"]=4002
   resp["errmsg"]="没有查到数据"
   c.RetData(resp)
   return
}
```

我们发现，每一个错误，我们都要执行c.RetData(resp)，这样也增加了很多重复代码，我们可以用一个小技巧 

将defer c.RetData(resp) 插入到var resp map[string]interface{}后面

代码如下：

```go
var resp map[string]interface{}//这是声明，不能存数据
即改成
resp:=make(map[string]interface{})
//每次return都会执行一次这行返回json数据
defer c.RetData(resp) 
```

现在我们就可以把代码里的return之前的c.RetData(resp)删除了。

然后把 resp["data"]=areas改一下，把上面o.QueryTable("area").All(&areas)查到并存到&areas里的数据传到resp["data"]里。

完整代码：

```go
package controllers

import (
	"github.com/astaxie/beego"
	"loveHome/models"
	"github.com/astaxie/beego/orm"
)

type AreaController struct {
	beego.Controller
}

func (this *AreaController) RetData(resp map[string]interface{})  {
	this.Data["json"] = resp
	this.ServeJSON()
}

func (c *AreaController) GetArea() {
	beego.Info("getarea succee")
	resp:=make(map[string]interface{})
	//每次return都会执行一次这行返回json数据
	defer c.RetData(resp)
	//从session拿数据

	//第一步，从数据中拿到数据。
	//声明一个数组用来存从数据库中查询到的所有城区数据。用数组
	o:=orm.NewOrm()
	var areas []models.Area

	//查询area表里的全部数据，存到areas缓存数组中，返回的是int64查询的条数，error错误信息
	num,err:=o.QueryTable("area").All(&areas)
	//如果没查询到返回的数据
	if err!=nil{
		beego.Info("数据错误")
		resp["errno"]=4001
		resp["errmsg"]="查询失败"
		return
	}
	if num==0{
		resp["errno"]=4002
		resp["errmsg"]="没有查到数据"
		return
	}
	//查询成功返回数据
	resp["errno"]=0
	resp["errmsg"]="OK"
	resp["data"]=areas //把上面查询到的数据传给data

	//第二步，把拿到的数据打包成json返回给前端。
	//上面已经defer c.RetData(resp)了，所以就不用写了
	beego.Info("query data succee ,resp = ",resp,"num = ",num)

}

```

好了。运行一下看看。bee run

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180618/b6adk36LbH.png?imageslim)

看一下开发者工具。areas不红了，Status Code:200，看一下取到的数据

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180618/78BJ469E83.png?imageslim)

成功取出来了。

看一下网站城区能显示吗

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180618/1HFl7A9hm6.png?imageslim)

发现也是可以的，好了。

## 1.7 显示登录注册按钮

我们再继续解决另外一个/api/v1.0/houses/index 

我们再给houseIndex创建一个方法,controllers/houseIndex.go

先创建一条路由设置，设置该路由调用方法GetHouseIndex

controllers用HouseIndexController{}

```go
beego.Router("/api/v1.0/houses/index", &controllers.HouseIndexController{},"get:GetHouseIndex")
```

然后去写该方法,把基本的框架先从area.go中拿过来。尽量复制，以防代码写错字母 

改一下controllers调用的结构体名,相关的都名都改过来

```go
package controllers

import (
   "github.com/astaxie/beego"
)

type HouseIndexController struct {
   beego.Controller
}

func (this *HouseIndexController) RetData(resp map[string]interface{})  {
   this.Data["json"] = resp
   this.ServeJSON()
}

func (this *HouseIndexController) GetHouseIndex() {
  //...
}
```

然后实现GetHouseIndex()

先把登录注册按钮显示出来。先伪装一下，添加下面代码

```go
resp:=make(map[string]interface{})
resp["errno"]=4001
resp["errmsg"]="查询失败"
this.RetData(resp)
```

另一个session也这样弄出来

houseIndex.go完整代码

```go
type HouseIndexController struct {
   beego.Controller
}

func (this *HouseIndexController) RetData(resp map[string]interface{})  {
   this.Data["json"] = resp
   this.ServeJSON()
}

func (this *HouseIndexController) GetHouseIndex() {
   resp:=make(map[string]interface{})
   resp["errno"]=4001
   resp["errmsg"]="查询失败"
   this.RetData(resp)
}
```

session.go完整代码

```go
type SessionController struct {
   beego.Controller
}

func (this *SessionController) RetData(resp map[string]interface{})  {
   this.Data["json"] = resp
   this.ServeJSON()
}

func (this *HouseIndexController) GetSessionData() {
   resp:=make(map[string]interface{})
   resp["errno"]=4001
   resp["errmsg"]="查询失败"
   this.RetData(resp)
}
```

router.go完整代码

```go
func init() {
    beego.Router("/", &controllers.MainController{})
    beego.Router("/api/v1.0/areas", &controllers.AreaController{},"get:GetArea")
    beego.Router("/api/v1.0/houses/index", &controllers.HouseIndexController{},"get:GetHouseIndex")
    beego.Router("/api/v1.0/session", &controllers.SessionController{},"get:GetSessionData")
}
```

好了。现在运行一下代码bee run

刷新一下网页localhost:8899 ,

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180618/kFIFL1cbHE.png?imageslim)

发现注册和登录按钮都出来了，成功。

看一下开发者工具三个请求的状态

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180618/cmmH8CafE0.png?imageslim)

都不红了。

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180618/4K5JKHdBHB.png?imageslim)

请求信息也获取的是正确 的。

## 1.8 注册代码实现

登录和注册按钮显示出来后，我们来写注册功能。

设计文档

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180618/2Kk2Fk3IBF.png?imageslim)

先测试一下，点击一下注册按钮

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180618/Df8Cf6aCjd.png?imageslim)

我们输入一些信息，看看能不能注册

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180618/bC7k9ILkhg.png?imageslim)

点立即注册，注册不了。会提交到一个users请求上，这个请求红了，没找到

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180618/B53FL0j3aE.png?imageslim)

所以我们要实现这个请求方法才能注册

现在先去创建一条路由。然后处理/api/v1.0/users请求，调用的是UserController结构体，用的方法是post方法，不是get了，请注意，因为注册是要提交数据，注册的方法是Reg

```
beego.Router("/api/v1.0/users", &controllers.UserController{},"post:Reg")
```

好了。我们现在去创建Reg方法。新建一个controllers/user.go

然后把session或houseIndex里的代码copy过来。然后改一下结构体名，方法名

```go
package controllers

import "github.com/astaxie/beego"

type UserController struct {
   beego.Controller
}

func (this *UserController) RetData(resp map[string]interface{})  {
   this.Data["json"] = resp
   this.ServeJSON()
}

func (this *UserController) Reg() {
   resp:=make(map[string]interface{})
   resp["errno"]=4001
   resp["errmsg"]="查询失败"
   this.RetData(resp)
}
```

好了。现在我们开始处理用户注册传过来的数据

官方有专门获取数据的方法https://beego.me/docs/mvc/controller/params.md

我们经常需要获取用户传递的数据，包括 Get、POST 等方式的请求，beego 里面会自动解析这些数据，你可以通过如下方式获取数据：

```go
GetString(key string) string

GetStrings(key string) []string

GetInt(key string) (int64, error)

GetBool(key string) (bool, error)

GetFloat(key string) (float64, error)
```

这个方法的意思是比如发送的数据是?username=yase&password=123456

我们用GetString(key string) string，key获取到的就是username，而返回值string获取到的是yase

但是我们传过来的数据并不是这样的，这样的在最早期叫明文传输。用户名和密码等用户数据都在导航栏里放着。大家这才发现这是不安全的，现在就很少用这种传输，都是不重要的数据才用这种传输。

现在一般都是用post传输了。比较安全

post数据现在都是传到Request Body里的内容

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180618/843i37C7Ka.png?imageslim)

像这样的数据，

处理的话用json.Unmarshal()来处理json传过来的数据。转换成结构体

例子：

```go
func (this *ObjectController) Post() {
//创建一个结构体用来存json解码的数据
    var ob models.Object
    //解码json数据并存到结构体ob中
    json.Unmarshal(this.Ctx.Input.RequestBody, &ob)
    objectid := models.AddOne(ob)
    this.Data["json"] = "{\"ObjectId\":\"" + objectid + "\"}"
    this.ServeJSON()
}
```

不过每次解码都用结构体。也是不太合理的，结构体太多了增加代码量

所以我们还是用map来存比较好

```go
resp:=make(map[string]interface{})
json.Unmarshal(this.Ctx.Input.RequestBody, &resp) //取地址
```

我们去看看传过来的数据有哪些

```json
{mobile: "111", password: "111", sms_code: "111"} 
```

现在我们看一下resp获取到数据了吗

```go
func (this *UserController) Reg() {
	resp:=make(map[string]interface{})
	json.Unmarshal(this.Ctx.Input.RequestBody, &resp)
	/*
	这是传过来的数据
	mobile: "111"
	password: "111"
	sms_code: "111"
	*/
	beego.Info(`resp["mobile"] = `,resp["mobile"])
	beego.Info(`resp["password"] = `,resp["password"])
	beego.Info(`resp["sms_code"] =`,resp["sms_code"])
}
```

终端显示。取到数据为nil,没取到数据。

```bash
2018/06/18 22:35:50.045 [I][user.go:26] resp["mobile"] =  <nil>
2018/06/18 22:35:50.049 [I] [user.go:27] resp["password"] =  <nil>
2018/06/18 22:35:50.049 [I][user.go:28] resp["sms_code"] = <nil>
```

发现问题。是因为如果要用request功能，先要在app.conf里开启此功能。添加如下一行

在配置文件里设置 copyrequestbody = true

添加后再试一下。

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180618/8F8b0igKg5.png?imageslim)

2018/06/18 22:38:03.845 [I][user.go:26] resp["mobile"] =  222
2018/06/18 22:38:03.845 [I] [user.go:27] resp["password"] =  222
2018/06/18 22:38:03.846 [I][user.go:28] resp["sms_code"] = 222

没有问题。获取到数据了。现在我们就可以把数据插入到数据库里了。

写插入数据库代码

```go
//插入数据库
o:=orm.NewOrm()
user:=models.User{} //啥数据不用传
user.Password_hash=resp["password"]
user.Name=resp["mobile"]
user.Mobile=resp["mobile"]
```

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180618/lFjK1GA6hL.png?imageslim)

发现报错。因为我们的resp的map是interface{}

而我们数据库的结构体是string类型，类型不匹配，所以报错，我们需要用断言来解决。

在后面加.(string)将interface{}强转成string类型,然后就不报错了。

```go
user.Password_hash=resp["password"].(string) //断言
user.Name=resp["mobile"].(string)   //断言
user.Mobile=resp["mobile"].(string)  //断言
```

现在插入数据库。

```go
//插入
id,err:=o.Insert(&user)
if err!=nil{
   resp["errno"]=4002
   resp["errmsg"]="注册失败"
   return
}
resp["errno"]=0
resp["errmsg"]="注册成功"
beego.Info("reg succee ,id = ",id)
```

发现少一行打包json数据方法，我们写上

```
defer this.RetData(resp) //打包成json
```

完整代码

```go
func (this *UserController) Reg() {
   resp:=make(map[string]interface{})
   defer this.RetData(resp)
   //获取前端传过来的json数据
   json.Unmarshal(this.Ctx.Input.RequestBody, &resp)
   /*
   这是传过来的数据
   mobile: "111"
   password: "111"
   sms_code: "111"
   */
   beego.Info(`resp["mobile"] = `,resp["mobile"])
   beego.Info(`resp["password"] = `,resp["password"])
   beego.Info(`resp["sms_code"] =`,resp["sms_code"])
   //插入数据库
   o:=orm.NewOrm()
   user:=models.User{} //获取User数据库结构体,啥数据不用传
    //把获取到的值写入到结构体中，类型不匹配，用断言解决
   user.Password_hash=resp["password"].(string)
   user.Name=resp["mobile"].(string)
   user.Mobile=resp["mobile"].(string)
   //把结构体中的信息插入到数据库中
   id,err:=o.Insert(&user)
   if err!=nil{
      resp["errno"]=4002
      resp["errmsg"]="注册失败"
      return
   }
   resp["errno"]=0
   resp["errmsg"]="注册成功"
   beego.Info("reg succee ,id = ",id)
}
```

现在运行项目 bee run ,注册一下看看能不能成功

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180618/ag153kdci1.png?imageslim)

成功注册后又返回到首页了。

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180618/IhLKHcG56E.png?imageslim)

看一下终端显示的，成功注册。

2018/06/18 22:50:55.070 [I][user.go:47] reg succee ,id =  1

看一下数据库里有没有数据

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180618/7J8b5fk2ab.png?imageslim)

刚才注册了三条。发现都有了

再说一下注册的步骤

1.设置路由

2.添加user.go

写注册代码，注意两点

>1 在配置文件里设置 `copyrequestbody = true` 
2 json.Unmarshal(this.Ctx.Input.RequestBody, &resp)

3.插入数据库中，插入的时候需要需要断言

## 1.9 session介绍

上一节我们把注册写好了。

但是注册有个小问题，一般我们注册成功的话会自动跳到首页并显示已登录状态。而不是未登录状态，再让你登一遍。

先看一下设计文档，让返回什么信息

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180619/04BKeLmh8K.png?imageslim)



现在实现代码

先写一个session.go文件。在controllers里

我们先把它登录状态写死，就是不管什么状态都是登录状态

```go
package controllers
import (
   "github.com/astaxie/beego"
   "loveHome/models"
)
type SessionController struct {
   beego.Controller
}
func (this *SessionController) RetData(resp map[string]interface{})  {
   this.Data["json"] = resp
   this.ServeJSON()
}
func (this *SessionController) GetSessionData() {
   resp:=make(map[string]interface{})
   user:=models.User{}
   user.Name="wyj"
   resp["errno"]=0
   resp["errmsg"]="Ok"
   resp["data"]=user
   this.RetData(resp)
}
```

我们直接返回注册成功的提示就可以显示登录状态了。

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180619/74B8BfH271.png?imageslim)

session在网站里，一般是一种加密的hash结构

比如我们去淘宝购物，登录，会发过去一个帐号密码，name,password,登录成功后返回首页

然后购物下单，再回到主页面，这时候不是未登录状态了，显示已登录状态了。就是不需要输入帐号密码了，我们只需要读sission就行了。

这个东西就是session机制，用来存储 你的帐号密码，这个帐号密码存在你自己的浏览器中。但是session是不可能明文去放的，而是将我们的帐号密码生成hash值，就是sessionid,通过sessionid去取我们的帐号密码来验证登录状态，有意思的是session是有时效性的，就是只可以用一段时间，过了这段时间，这个session系统就给你删除了，不让用了。淘宝网站又会让你重新登录一次。

就像我们的注册页面，register.html，如果刚才已经登录过了。再访问注册页面，还是可以注册，并不是提示已经登录过了。所以这不是很人性化。

那么我们现在就去实现一下这个功能。

我们去controllers/session.go里实现session管理代码

官方开发文档里有很详细的session的教程

https://beego.me/docs/mvc/controller/session.md

## 1.10 错误码文件

一般我们开发后端项目，返回给前端错误码的时候，一般只会返回很简单的几个字，比如，数据错误，注册失败，请求错误，显示不够详细，但是前端细心的给了我们一些错误的常量供我们调用。

```go
/**
* @file recode.go
* @brief  返回码
* @author

Aceld(LiuDanbing)

email: danbing.at@gmail.com
Blog: http://www.gitbook.com/@aceld

* @version 1.0
* @date 2017-11-05
*/
package utils

const (
   RECODE_OK         = "0"
   RECODE_DBERR      = "4001"
   RECODE_NODATA     = "4002"
   RECODE_DATAEXIST  = "4003"
   RECODE_DATAERR    = "4004"
   RECODE_SESSIONERR = "4101"
   RECODE_LOGINERR   = "4102"
   RECODE_PARAMERR   = "4103"
   RECODE_USERERR    = "4104"
   RECODE_ROLEERR    = "4105"
   RECODE_PWDERR     = "4106"
   RECODE_REQERR     = "4201"
   RECODE_IPERR      = "4202"
   RECODE_THIRDERR   = "4301"
   RECODE_IOERR      = "4302"
   RECODE_SERVERERR  = "4500"
   RECODE_UNKNOWERR  = "4501"
)

var recodeText = map[string]string{
   RECODE_OK:         "成功",
   RECODE_DBERR:      "数据库查询错误",
   RECODE_NODATA:     "无数据",
   RECODE_DATAEXIST:  "数据已存在",
   RECODE_DATAERR:    "数据错误",
   RECODE_SESSIONERR: "用户未登录",
   RECODE_LOGINERR:   "用户登录失败",
   RECODE_PARAMERR:   "参数错误",
   RECODE_USERERR:    "用户不存在或未激活",
   RECODE_ROLEERR:    "用户身份错误",
   RECODE_PWDERR:     "密码错误",
   RECODE_REQERR:     "非法请求或请求次数受限",
   RECODE_IPERR:      "IP受限",
   RECODE_THIRDERR:   "第三方系统错误",
   RECODE_IOERR:      "文件读写错误",
   RECODE_SERVERERR:  "内部错误",
   RECODE_UNKNOWERR:  "未知错误",
}

func RecodeText(code string) string {
   str, ok := recodeText[code]
   if ok {
      return str
   }
   return recodeText[RECODE_UNKNOWERR]
}
```

前端提供给我们这些错误码，我们就可以调用了，并实现了一个函数方法，调用错误码并返回给前端错误内容。

这样做的好处是，我们可以全局封装一下，方便以后修改，如果不这样做，要修改的话就需要每个go文件里的错误代码都要修改一次，无非是增加了不必要的工作量。

我们把上面的错误码拿来后，放到models目录recode.go

使用的话很简单，我们找到以前写错误码的地方，把错误码都改掉

先导入包"loveHome/models"

然后将错误码修改成这样就可以了。

```
resp["errno"]=models.RECODE_DATAERR
resp["errmsg"]=models.RecodeText(models.RECODE_DATAERR)
```

controllers/area.go

controllers/houseIndex.go

controllers/session.go

controllers/user.go

目前是这4个文件需要修改。

## 1.11 session控制

beego一般要开启session功能的话，有两种方法，

第一种：只要在 main 入口函数中设置如下：

```go
beego.BConfig.WebConfig.Session.SessionOn = true 
```

第二种：通过配置文件conf/app.conf配置如下： 

```
sessionon = true
```

session 有几个方便的方法：

- SetSession(name string, value interface{})

- GetSession(name string) interface{}

- DelSession(name string)

- SessionRegenerateID()

- DestroySession()

session官方使用例子

```go
func (this *MainController) Get() {
    v := this.GetSession("asta")
    if v == nil {
        this.SetSession("asta", int(1))
        this.Data["num"] = 0
    } else {
        this.SetSession("asta", v.(int)+1)
        this.Data["num"] = v.(int)
    }
    this.TplName = "index.tpl"
}
```

session 操作主要有设置 session、获取 session、删除 session。

接下来我们写代码看看session如何使用。

比如我们注册完了肯定要先设置一个session，用SetSession()

首先，右上角，我们肯定是要显示谁在注册，注册好了后，显示一个名字出来。所以我们这里就应该注册好后返回一个user.name回去。

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180619/Emb8314i42.png?imageslim)

先写注册好了SetSession()代码。

controllers/user.go

这个user.Name是我们刚才已经获取的

```go
user.Name=resp["mobile"].(string)
```

 我们需要把这个user.Name，Set回去。

```go
//设置一个session,用来登录后显示用户名
this.SetSession("name",user.Name)
```

然后controllers/session.go里修改注册后获取GetSession()

```go
func (this *SessionController) GetSessionData() {
   resp:=make(map[string]interface{})
   defer this.RetData(resp)//将数据打包成json返回给前端
//获取User结构体对象
   user:=models.User{}
   //获取session
   name:=this.GetSession("name")
   //判断如果获取到session需要做什么
   if name!=nil{
      user.Name=name.(string) //需要断言
      //下面两行是返回状态码
      resp["errno"]=models.RECODE_OK
      resp["errmsg"]=models.RecodeText(models.RECODE_OK)
      把user结构体的数据传给data
      resp["data"]=user
   }
}
```

我们要实现的是登录后，给登录的用户设置session，并返回注册成功信息，返回到主页，右上角显示登录状态已登录，并显示登录者的名字

![1529422453842](C:\Users\Administrator\AppData\Local\Temp\1529422453842.png)

一般前端获取到的名字信息在json的data里，名字一般是data里的{"name":"wyj"}，就是这个name后面的值需要显示在登录右上角。

{
  "data": {
    "user_id": 0,
    "Name": "2222", 这个就是需要显示的值 
    "Password_hash": "",
    "Mobile": "",
    "Real_name": "",
    "Id_card": "",
    "Avatar_url": "",
    "Houses": null,
    "Orders": null
  },
  "errmsg": "成功",
  "errno": "0"
}

所以我们需要判断session里有没有数据，如果有数据，我们是不是需要显示一下。显示后，就代表我已经在登录状态了。

但是发现一个问题。就是注册后session处只显示小图标，不显示用户名。很奇怪。

最后经过检查。发现发送给前端的。json数据的data部分首字母大写了。所以获取不到。原因是因为models.go里的User结构体后面的json:"name"前面我刚开始是用的tab来间隔的。所以导致json别名设置没生效，这个地方要注意。千万不要用tab。以后无论写任何代码都不要用tab。 这真是坑啊。

还好找到原因了。显示正常了

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180620/IJ3JA13A7a.png?imageslim)

虽然现在登录正常了。但是我们没法退出。

现在我们就开始做退出功能

## 1.12 删除session

我们看一下退出的设计文档的状态码，需要用的方法是DELETE

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180620/f5bBD7G8ge.png?imageslim)



现在我们测试一下退出功能。发现退出没反映。看开发者工具。报红了

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180620/9iHHKF1jC5.png?imageslim)

现在我们把退出功能实现了。其实就是删除session

开始肯定是要先添加一条路由

```
/*
   退出登录
   Request URL: http://localhost:8899/api/v1.0/session
Request Method: DELETE
   */
beego.Router("/api/v1.0/session", &controllers.UserController{},"delete:Delete")
```

但是发现这条路由请求的也是session，和前面我们登录那条路由是一样的。这要造成冲突，后面的session路由会覆盖前面的，前面的session就失效了。

所以我们可以 样写，直接加在登录那条session路由，再多加一条方法。因为每条路由可以加多个方法。多个方法用分号分割

```
beego.Router("/api/v1.0/session", &controllers.SessionController{},"get:GetSessionData;delete:DeleteSessionData")
```

然后在session.go里开始写删除session代码，删除session就比较简单了

```go
func (this *SessionController) DeleteSessionData() {
   resp:=make(map[string]interface{})
   defer this.RetData(resp)
   this.DelSession("name")
   resp["errno"]=models.RECODE_OK
   resp["errmsg"]=models.RecodeText(models.RECODE_OK)
}
```

我们来试一下。运行服务器bee run

随便注册一个

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180620/FA927bCBb5.png?imageslim)

登录成功。

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180620/bcJHAEAgaE.png?imageslim)

点666，进入个人中心。然后点退出。

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180620/Dla09El0km.png?imageslim)

退出成功。返回首页

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180620/09JFA17hBK.png?imageslim)

完美。现在注册和退出写完了。

