# 第五天笔记
## 1.0 程序优化方法

========================优化 start===============================

程序做到这，发现一个问题。因为我们用的服务器是虚拟机，属于外网，每次上传图片，上传redis都需要改配置的IP，端口，万一IP变了，再修改就麻烦死了。所以我们把这个配置信息存到conf/app.conf里面。方便读取

先加修改一下app.conf配置文件，我的配置文件如下，请根据自己的环境修改

```go
appname = iHome
httpport = 9998
httpaddr = "10.0.151.242"
runmode = dev
copyrequestbody = true
sessionon = true
redisaddr = "127.0.0.1"
redisport = 6379
redisdbnum = 0
mysqladdr = "127.0.0.1"
mysqlport = 3306
mysqldbname = "lovehome"
fdfs_http_addr = "10.0.151.220:9998"
```

好了。配置文件写好了。现在我们去写一个方法，来读取这些配置文件。方便我们调用

新建文件utils/config.go

```go
package utils

import (
   "github.com/astaxie/beego/config"
   "github.com/astaxie/beego"
)

//定义config变量
var(
   G_server_addr string  //服务器ip地址
   G_server_port string //服务器端口
   G_redis_addr string  //redis ip地址
   G_redis_port string //redis port端口
   G_redis_dbnum string //redis db编号
   G_mysql_addr string //mysql ip地址
   G_mysql_port string //mysql port端品
   G_mysql_dbname string //mysql db库名
   G_fdfs_http_addr string //fdfs nginx ip地址
)

func InitConfig()  {
   //从配置文件读取配置信息
   appconf,err:=config.NewConfig("ini","conf/app.conf")
   if err!=nil{
      beego.Debug(err)
      return 
   }
   G_server_addr=appconf.String("httpaddr")
   G_server_port=appconf.String("httpport")
   G_redis_addr=appconf.String("redisaddr")
   G_redis_port=appconf.String("redisport")
   G_redis_dbnum=appconf.String("redisdbnum")
   G_mysql_addr=appconf.String("mysqladdr")
   G_mysql_port=appconf.String("mysqlport")
   G_mysql_dbname=appconf.String("mysqldbname")
   G_fdfs_http_addr=appconf.String("fdfs_http_addr")
}
func init()  {
   InitConfig()
}
```

好了。现在我们就可以用了。用之前需要先导入utils包

关于图片显示问题。因为我们的图片显示在了fdfs服务器上，我的服务器是外网的。所以需要网址进行拼接。所以我们最好是创建一个函数把图片路径传进去，返回接拼好的路径。

在utils下再建一个misc.go文件。代码比较简单。

```go
package utils

/* 将url加上 http://IP:PROT/  前缀 */
func AddDomain2Url(url string) (domain_url string)  {
   domain_url="http://"+G_fdfs_http_addr+"/"+url
   return domain_url
}
```

好了。现在就可以去把需要显示图片的地方改一下了。

主要修改的文件

area.go

```
redis_config_map:=map[string]string{
   "key":"lovehome",
   "conn":utils.G_redis_addr+":"+utils.G_redis_port,
   "dbNum":utils.G_redis_dbnum,
}
redis_config,_:=json.Marshal(redis_config_map)
cache_conn, err := cache.NewCache("redis", string(redis_config))
```

models/models.go

```
for _,img_url:=range this.Images{
   //遍历出来的图片url存到数组中
   img_urls=append(img_urls,utils.AddDomain2Url(img_url.Url))
}
```

user.go的PostAvatar

最后拼接图片需要改

```
avatar_url["avatar_url"]=utils.AddDomain2Url(uploadResponse.RemoteFileId)
```

user.go的GetUserData

最后获取图片需要改

```
user.Avatar_url=utils.AddDomain2Url(user.Avatar_url)
```

models/models.go

获取房屋图片路径。

```
"user_avatar":utils.AddDomain2Url(this.User.Avatar_url),
```

好了。优化完成了。这样程序就比较好维护了

========================优化 end===============================

关于昨天的内容，有一个实名认证检查，我们没有公安局的认证接口，所以这个没法实现。其实都差不多。

## 1.1 上传房源图片信息

前端需要的信息

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180623/F9LfE4j1fE.png?imageslim)
![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180623/82F4bJ1e3g.png?imageslim)
业务逻辑图

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180623/7L11F6k8hl.png?imageslim)
![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180623/Kjac3dKHBF.png?imageslim)

测试一下上传图片，发现请求地址和方法是

1. Request URL: http://10.0.151.242:8899/api/v1.0/houses/8/images

2. Request Method: POST

先添加一条路由。

```go
/*
房源图片上传
   1. Request URL: http://10.0.151.242:8899/api/v1.0/houses/8/images
   2. Request Method: POST
*/
beego.Router("/api/v1.0/houses/?:id/images", &controllers.HouseController{},"get:UploadHouseImage")
```

再写一个框架

```
func (this *HouseController) UploadHouseImage()  {
   resp:=make(map[string]interface{})
   resp["errno"]=models.RECODE_OK
   resp["errmsg"]=models.RecodeText(models.RECODE_OK)
   defer this.RetData(resp)
}
```

好了。现在分析一下业务流程该怎么写

1.从用户请求中获取到图片数据

2.将用户二进制数据存到fdfs中。得到fileid

3.从请求的url中获得house_id

4.查看该房屋的index_image_url主图是否为空

​	为空则更将fileid路径赋值给index_image_url

5.主图不为空，将该图片的fileid字段追加（关联查询）到houseimage字段中插入到house_image表中

6.拼接完整域名url_fileid

7.返回给前端json

完整代码

```go
func (this *HouseController) UploadHouseImage()  {
   resp:=make(map[string]interface{})
   resp["errno"]=models.RECODE_OK
   resp["errmsg"]=models.RecodeText(models.RECODE_OK)
   defer this.RetData(resp)

   //1.从用户请求中获取到图片数据
   fileData,hd,err:=this.GetFile("house_image")
   defer fileData.Close() //获取完后等程序执行完后关掉连接
   beego.Info("========",fileData,hd,err)
   //没拿到图片
   if fileData==nil{
      resp["errno"]=models.RECODE_REQERR
      resp["errmsg"]=models.RecodeText(models.RECODE_REQERR)
      return
   }
   if err!=nil{
      resp["errno"]=models.RECODE_REQERR
      resp["errmsg"]=models.RecodeText(models.RECODE_REQERR)
      return
   }
   //2.将用户二进制数据存到fdfs中。得到fileid
   suffix:=path.Ext(hd.Filename)
   //判断上传文件的合法性
   if suffix!=".jpg"&&suffix!=".png"&&suffix!=".gif"&&suffix!=".jpeg"{
      resp["errno"]=models.RECODE_REQERR
      resp["errmsg"]=models.RecodeText(models.RECODE_REQERR)
      return
   }
   //去掉.
   suffixStr:=suffix[1:]
   //创建hd.Size大小的[]byte数组用来存放fileData.Read读出来的[]byte数据
   fileBuffer:=make([]byte,hd.Size)
   //读出的数据存到[]byte数组中
   _,err=fileData.Read(fileBuffer)
   if err!=nil{
      resp["errno"]=models.RECODE_IOERR
      resp["errmsg"]=models.RecodeText(models.RECODE_IOERR)
      return
   }
   //将图片上传到fdfs获取到fileid
   uploadResponse,err:=UploadByBuffer(fileBuffer,suffixStr)
   //3.从请求的url中获得house_id
   house_id:=this.Ctx.Input.Param(":id")
   //4.查看该房屋的index_image_url主图是否为空
   house:=models.House{} //打开house结构体
   //house结构体拿到houseid数据
   house.Id,_=strconv.Atoi(house_id)
   o:=orm.NewOrm() //创建orm
   errRead:=o.Read(&house) //读取house数据库where user.id
   if errRead!=nil{
      resp["errno"]=models.RECODE_DBERR
      resp["errmsg"]=models.RecodeText(models.RECODE_DBERR)
      return
   }
   //查询index_image_url是否为空
   //为空则更将fileid路径赋值给index_image_url
   if house.Index_image_url==""{
      house.Index_image_url=uploadResponse.RemoteFileId
   }
   //5.主图不为空，将该图片的fileid字段追加（关联查询）到houseimage字段中插入到house_image表中,并拿到了HouseImage，里面也有数据了
   //HouseImage功能就是如果主图有了，就追加其它图片的。
   house_image:=models.HouseImage{House:&house,Url:uploadResponse.RemoteFileId}
   //将house_image和house相关联,往house.Images里追加附加图片，可以追加多个
   house.Images=append(house.Images,&house_image)//向把HouseImage对象的数据添加到house.Images
   //将house_image入库，插入到house_image表中
   if _,err:=o.Insert(&house_image);err!=nil{
      resp["errno"]=models.RECODE_DBERR
      resp["errmsg"]=models.RecodeText(models.RECODE_DBERR)
      return
   }
   //将house更新入库，插入到house中
   if _,err:=o.Update(&house);err!=nil{
      resp["errno"]=models.RECODE_DBERR
      resp["errmsg"]=models.RecodeText(models.RECODE_DBERR)
      return
   }
   //6.拼接完整域名url_fileid
   respData:=make(map[string]string)
   respData["url"]=utils.AddDomain2Url(uploadResponse.RemoteFileId)

   //7.返回给前端json
   resp["data"]=respData
}
```

好了。现在测试一下。看看能不能上传图片

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180625/m5j3k9jJac.png?imageslim)

上传成功。并且图片可以轮训播放。可以插入多张图片。

## 1.2 请求房源详细信息

先看一下房源详细信息在哪里显示

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180623/2milDk472H.png?imageslim)

在我的房源里，

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180623/LgEg8bJHl6.png?imageslim)

然后我们发现随便点一下房源，房源的详细信息为空，右边报红。

看一下用什么请求来处理。

1. Request URL: http://localhost:8899/api/v1.0/houses/2

2. Request Method: GET

先添加一条路由吧，看一下上面这个请求地址，有点奇怪，怎么houses后面的数字还不一样。原来是house.Id呀。这个路由就应该用正则匹配来加了

```
/*
房源详细信息
   1. Request URL: http://localhost:8899/api/v1.0/houses/2
   2. Request Method: GET
*/
//路由这个问题，就是匹配一个或多个字符，不论数字还是字符
beego.Router("/api/v1.0/houses/?:id", &controllers.HouseController{},"get:GetDetailHouseData")
```

现在写一个这个方法

看一下业务需要什么数据

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180623/45296L1jmL.png?imageslim)
![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180623/4ik2HHkHB3.png?imageslim)
![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180623/H4ICmmLh3H.png?imageslim)
![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180623/gel9J7ChL8.png?imageslim)
业务逻辑图

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180623/HJIh30Ekcc.png?imageslim)

业务流程：

1.从session获取user_id

2.从请求的url中得到房屋id

3.从redis缓存获取当前房屋的数据,如果有该房屋，则直接返回正确的json

4.通过查询数据库得到当前房屋的所有信息

5.关联查询area,user,images,facilities等表，

这个需要说一下，这个四个表关联查询，其实就是house表分别和这四个表做关联查询。

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180623/6f25E7cdmI.png?imageslim)

6.将房屋详细的json数据存放redis缓存中

7.返回json数据给前端。

好了。我们现在去写这个业务代码，其实挺复杂的。

还是先写一个框架

```
func (this *UserController) GetDetailHouseData()  {
   //用来存json数据的
   resp:=make(map[string]interface{})
	resp["errno"]=models.RECODE_OK
	resp["errmsg"]=models.RecodeText(models.RECODE_OK)
	defer this.RetData(resp)
   //1.从session获取user_id
 
   //2.从请求的url中得到房屋id

   //3.从redis缓存获取当前房屋的数据,如果有该房屋，则直接返回正确的json

   //4.通过查询数据库得到当前房屋的所有信息

   //5.关联查询area,user,images,facilities等表
   
   //6.将房屋详细的json数据存放redis缓存中

   //7.返回json数据给前端。
	
}
```

好了。框架写好了。现在开始写代码吧

1.从session获取user_id

```
user_id:=this.GetSession("user_id")
```

 2.从请求的url中得到房屋id

```
//Param中的id值可以随便换，但要是router中的对应
house_id:=this.Ctx.Input.Param(":id")
//转换一下interface{}转成int
h_id,err:=strconv.Atoi(house_id)
if err!=nil{
	resp["errno"]=models.RECODE_REQERR
	resp["errmsg"]=models.RecodeText(models.RECODE_REQERR)
	return
}
```

 3.从redis缓存获取当前房屋的数据,如果有该房屋，则直接返回正确的json

稍后做

 4.通过查询数据库得到当前房屋的所有信息

```go
//4.如果缓存没有房屋数据,那么从数据库中获取数据,再存入缓存中,然后返回给前端
	o:=orm.NewOrm()
	// --- 载入关系查询 -----
	house:=models.House{Id:h_id}
	//把房子信息读出来
	if err:= o.Read(&house);err!=nil{
		resp["errno"]=models.RECODE_DBERR
		resp["errmsg"]=models.RecodeText(models.RECODE_DBERR)
		return
	}
```

 5.关联查询area,user,images,facilities等表

我们先看一下需要返回什么数据

需要的是data中返回house的一些数据，包括house信息、comments评论信息、facilities信息、img_urls信息，其中commments会有很多条评论，是数组，还有facilities信息、img_urls信息，都是数组。最后还有一个user_id数据和house数据是同级的。

通过以上分析，发现house数据里存的是house、comments、facilities、img_urls等数据，而house存在data里

上面房子信息已经读取出来了。我们现在去做关键的关联查询部分。

官方提供了一个简便的方法LoadRelated。我们可以拿来直接用，省去省很多代码的麻烦。

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180624/Kee495DCcb.png?imageslim)

官方的这个功能可以载入所有的一对一，一对多，多对多的关系字段 。

首先读取出数据

然后将读出来的数据post和Tags做关系字段载入，就是关联查询的意思。这样就能查出来房子所关联的表中的数据了。

我们的项目主要是house表分别和关联的四个字段area,user,images,facilities做关联查询。属于一对多关系，一套房子有多个设施图片。如果不关联，就找不到对应的那个表。

代码如下。

```go
o.LoadRelated(&house,"Area")
o.LoadRelated(&house,"User")
o.LoadRelated(&house,"Images")
o.LoadRelated(&house,"Facilities")
```

写到这，信息还不够，还有房屋图片，房屋设施，评论还没有获取到。这个比较麻烦，我们为了代码简洁，我们再创建一个方法专门用来查询这几个数据。

在models.go里建一个方法To_one_house_desc，这个方法属于house结构体的方法，专门用来获取房屋图片，房屋设施，评论的数据

```go
func (this *House)To_one_house_desc() interface{} {
   //创建一个map用来存house数据，并把获取到的house数据存在这里
   house_desc:=map[string]interface{}{
      "hid":this.Id,
      "user_id":this.User.Id,
      "user_name":this.User.Name,
      "user_avatar":this.User.Avatar_url,
      "title":this.Title,
      "price":this.Price,
      "address":this.Address,
      "room_count":this.Room_count,
      "acreage":this.Acreage,
      "unit":this.Unit,
      "capacity":this.Capacity,
      "beds":this.Beds,
      "deposit":this.Deposit,
      "min_days":this.Min_days,
      "max_days":this.Max_days,
   }
   //其它没有获取到的数据
   //房屋图片
   img_urls:=[]string{}
   for _,img_url:=range this.Images{
      //遍历出来的图片url存到数组中
      img_urls=append(img_urls,img_url.Url)
   }
   house_desc["img_urls"]=img_urls

   //房屋设施
   facilities:=[]int{}
   for _,Facility:=range this.Facilities{
      //遍历出来的设施id存到数组中
      facilities=append(facilities,Facility.Id)
   }
   house_desc["facilities"]=facilities

   //评论信息
   //用来存评论的
   comments:=[]interface{}{} //定义interface数组需要两个花括号
   //用来存订单的
   orders:=[]OrderHouse{}
   o:=orm.NewOrm()
   //查询所有当前房源的订单信息
   order_num,err:=o.QueryTable("order_house").Filter("house__id",this.Id).Filter("status",ORDER_STATUS_COMPLETE).OrderBy("-ctime").Limit(10).All(&orders)
   if err!=nil{
      beego.Error("select orders comments error, err =", err, "house id = ", this.Id)
   }
   for i:=0; i<int(order_num);i++  {
      //order_house表和User表关联查询
      o.LoadRelated(&orders[i],"User")
      var username string
      if orders[i].User.Name==""{
         username="匿名用户"
      }else{
         username=orders[i].User.Name
      }
      comment:=map[string]string{
         "comment":orders[i].Comment,
         "user_name":username,
         "ctime":orders[i].Ctime.Format("2006-01-02 15:04:05"),
      }
      comments=append(comments,comment)
   }
   house_desc["comments"]=comments
   return house_desc
}
```

获取到之后，现在可以把json数据打包返回给前端了。

```
respData:=make(map[string]interface{})
respData["house"]=house.To_one_house_desc()
respData["user_id"]=user_id
resp["data"]=respData
```

好了。可以看一下数据正常吗。

![1529838613447](C:\Users\Administrator\AppData\Local\Temp\1529838613447.png)

![1529838619650](C:\Users\Administrator\AppData\Local\Temp\1529838619650.png)

数据正常。房东，设施都显示出来了。图片没显示是因为路径不对。我们一会改一下。

好了。现在需要做的是怎么把这些数据存到redis中，提高读取效率。



6.将房屋详细的json数据存放redis缓存中,开始写代码

先写连接redis的代码

```
redis_config_map:=map[string]string{
   "key":"lovehome",
   "conn":utils.G_redis_addr+":"+utils.G_redis_port,
   "dbNum":utils.G_redis_dbnum,
}
redis_config,_:=json.Marshal(redis_config_map)
cache_conn, err := cache.NewCache("redis", string(redis_config))
if err!=nil{
   resp["errno"]=models.RECODE_REQERR
   resp["errmsg"]=models.RecodeText(models.RECODE_REQERR)
   return
}
```

然后写从redis中查询数据的代码

```go
//先把house有的东西返回给house的json
respData:=make(map[string]interface{})
//设置一个变量，每个房子插入redis不能一样，容易覆盖，所以用house_id做为key，比如lovehome:1,lovehome:2
house_page_key:=house_id
house_info_value:=cache_conn.Get(house_page_key)
if house_info_value!=nil{
   beego.Debug("======= get house info desc  from CACHE!!! ========")
   //返回json的user_id
   respData["user_id"]=user_id
   //返回json的house信息
   house_info:=make(map[string]interface{})
   //解码json并存到house_info里
   json.Unmarshal(house_info_value.([]byte),&house_info)
   //将house_info的map返回json的house给前端
   respData["house"]=house_info
   resp["data"]=respData
   return
}
```

如果redis中没数据，那么就从数据库中查询到数据插入到redis中，看代码

```go
//6.将房屋详细的json数据存放redis缓存中
//house_page_key是上面定义的一个变量，其实就是house_id。为了实现每个房子在redis中key值不同，所以最好就是用house_id来区分
house_info_value,_=json.Marshal(house.To_one_house_desc())
cache_conn.Put(house_page_key,house_info_value,3600*time.Second)
```

好了。代码写好了。附上完整代码

```go
func (this *HouseController) GetDetailHouseData()  {

   //用来存json数据的
   resp:=make(map[string]interface{})
   resp["errno"]=models.RECODE_OK
   resp["errmsg"]=models.RecodeText(models.RECODE_OK)
   defer this.RetData(resp)

   //1.从session获取user_id
   user_id:=this.GetSession("user_id")

   //2.从请求的url中得到房屋id
   //Param中的id值可以随便换，但要是router中的对应
   house_id:=this.Ctx.Input.Param(":id")
   //转换一下interface{}转成int
   h_id,err:=strconv.Atoi(house_id)
   if err!=nil{
      resp["errno"]=models.RECODE_REQERR
      resp["errmsg"]=models.RecodeText(models.RECODE_REQERR)
      return
   }
   //3.从redis缓存获取当前房屋的数据,如果有该房屋，则直接返回正确的json
   redis_config_map:=map[string]string{
      "key":"lovehome",
      "conn":utils.G_redis_addr+":"+utils.G_redis_port,
      "dbNum":utils.G_redis_dbnum,
   }
   redis_config,_:=json.Marshal(redis_config_map)
   cache_conn, err := cache.NewCache("redis", string(redis_config))
   if err!=nil{
      resp["errno"]=models.RECODE_REQERR
      resp["errmsg"]=models.RecodeText(models.RECODE_REQERR)
      return
   }
   //先把house有的东西返回给house的json
   respData:=make(map[string]interface{})
   //设置一个变量，每个房子插入redis不能一样，容易覆盖，所以用house_id做为key，比如lovehome:1,lovehome:2
   house_page_key:=house_id
   house_info_value:=cache_conn.Get(house_page_key)
   if house_info_value!=nil{
      beego.Debug("======= get house info desc  from CACHE!!! ========")
      //返回json的user_id
      respData["user_id"]=user_id
      //返回json的house信息
      house_info:=make(map[string]interface{})
      //解码json并存到house_info里
      json.Unmarshal(house_info_value.([]byte),&house_info)
      //将house_info的map返回json的house给前端
      respData["house"]=house_info
      resp["data"]=respData
      return
   }
   //4.如果缓存没有房屋数据,那么从数据库中获取数据,再存入缓存中,然后返回给前端
   o:=orm.NewOrm()
   // --- 载入关系查询 -----
   house:=models.House{Id:h_id}
   //把房子信息读出来
   if err:= o.Read(&house);err!=nil{
      resp["errno"]=models.RECODE_DBERR
      resp["errmsg"]=models.RecodeText(models.RECODE_DBERR)
      return
   }
   //5.关联查询area,user,images,facilities等表
   o.LoadRelated(&house,"Area")
   o.LoadRelated(&house,"User")
   o.LoadRelated(&house,"Images")
   o.LoadRelated(&house,"Facilities")


   //6.将房屋详细的json数据存放redis缓存中
   house_info_value,_=json.Marshal(house.To_one_house_desc())
   cache_conn.Put(house_page_key,house_info_value,3600*time.Second)

   //7.返回json数据给前端。
   respData["house"]=house.To_one_house_desc()
   respData["user_id"]=user_id
   resp["data"]=respData
}
```

好了。请求房源详细信息代码已经写完了。现在去测试一下。

![1529846473457](C:\Users\Administrator\AppData\Local\Temp\1529846473457.png)

没有问题。房东姓名，房东地址，房间设施等信息都显示正确，json也显示正确。

![1529846520558](C:\Users\Administrator\AppData\Local\Temp\1529846520558.png)

redis中也正确的插入了信息。

![1529846538944](C:\Users\Administrator\AppData\Local\Temp\1529846538944.png)

并且读取房源信息的时候也是从redis中读取的。

下面开始写首页的房屋搜索信息，定这个用户才能搜索到房屋，才能预定房源，后面的代码才能继续。

## 1.3 首页房源列表信息

首页房源请求地址是

1. Request URL: http://10.0.151.242:8899/api/v1.0/houses/index
2. Request Method: GET

先添加一条路由。以前好像加过。
是加过

```
/*
  用户请求房源首页列表信息
Request URL: http://localhost:8899/api/v1.0/houses/index
Request Method: GET
  */
  beego.Router("/api/v1.0/houses/index", &controllers.HouseIndexController{},"get:GetHouseIndex")
```

然后始实现代码，先分析一下首页需要什么数据
```
{
  "data": [
    {
      "address": "1111",
      "area_name": "海淀区",
      "ctime": "2018-06-23 08:58:44",
      "house_id": 1,
      "img_url": "http://10.0.151.220:9998/group1\\M00/00/00/CgCX3FswPzmAWKKQAAFqdROOF2Y013.jpg",
      "order_count": 0,
      "price": 11100,
      "room_count": 111,
      "title": "111",
      "user_avatar": "http://10.0.151.220:9998/group1\\M00/00/00/CgCX3Fsvq52AI-QaAAFqdROOF2Y071.jpg"
    },
    {
      "address": "222",
      "area_name": "昌平区",
      "ctime": "2018-06-23 13:00:23",
      "house_id": 2,
      "img_url": "http://10.0.151.220:9998/group1\\M00/00/00/CgCX3FswPzmAWKKQAAFqdROOF2Y013.jpg",
      "order_count": 0,
      "price": 22200,
      "room_count": 22,
      "title": "222",
      "user_avatar": "http://10.0.151.220:9998/group1\\M00/00/00/CgCX3Fsvq52AI-QaAAFqdROOF2Y071.jpg"
    },
    {
      "address": "333",
      "area_name": "通州区",
      "ctime": "2018-06-23 13:12:54",
      "house_id": 3,
      "img_url": "http://10.0.151.220:9998/group1\\M00/00/00/CgCX3FswPzmAWKKQAAFqdROOF2Y013.jpg",
      "order_count": 0,
      "price": 33300,
      "room_count": 333,
      "title": "333",
      "user_avatar": "http://10.0.151.220:9998/group1\\M00/00/00/CgCX3Fsvq52AI-QaAAFqdROOF2Y071.jpg"
    },
    {
      "address": "444",
      "area_name": "顺义区",
      "ctime": "2018-06-23 13:25:49",
      "house_id": 4,
      "img_url": "http://10.0.151.220:9998/group1\\M00/00/00/CgCX3FswPzmAWKKQAAFqdROOF2Y013.jpg",
      "order_count": 0,
      "price": 44400,
      "room_count": 444,
      "title": "444",
      "user_avatar": "http://10.0.151.220:9998/group1\\M00/00/00/CgCX3Fsvq52AI-QaAAFqdROOF2Y071.jpg"
    },
    {
      "address": "666",
      "area_name": "朝阳区",
      "ctime": "2018-06-23 13:31:44",
      "house_id": 5,
      "img_url": "http://10.0.151.220:9998/group1\\M00/00/00/CgCX3FswPzmAWKKQAAFqdROOF2Y013.jpg",
      "order_count": 0,
      "price": 66600,
      "room_count": 666,
      "title": "666",
      "user_avatar": "http://10.0.151.220:9998/group1\\M00/00/00/CgCX3Fsvq52AI-QaAAFqdROOF2Y071.jpg"
    }
  ],
  "errmsg": "成功",
  "errno": "0"
}
```

发现上面要的信息不多，data里是一些房源信息，都存在数组中。再返回errno,errmsg即可。

然后我们开始写代码，先写一个框架

```
//请求首页房源
func (this *HouseController) GetHouseIndex() {
   resp:=make(map[string]interface{})
   resp["errno"]=models.RECODE_OK
   resp["errmsg"]=models.RecodeText(models.RECODE_OK)
   defer this.RetData(resp)
   beego.Debug("Index Houses....")

   //1 从缓存服务器中请求 "home_page_data" 字段,如果有值就直接返回
	
   //2 如果缓存没有,需要从数据库中查询到房屋列表

   //3.将data存入缓存中
 
   //4.返回前端data
   resp["data"]=respData
   return
}
```

好了。框架有了。我们开始往里加代码

先写2 如果缓存没有,需要从数据库中查询到房屋列表

```
houses:=[]models.House{}
	o:=orm.NewOrm()
	//查询数据库中所有房子信息
	if _,err:=o.QueryTable("house").Limit(models.HOME_PAGE_MAX_HOUSES).All(&houses);err==nil{
		//循环遍历这些房子及关联表查询
		for _,house:=range houses{、
		//这里不用关联查询也可以的，不知道为什么源码里要用
			//o.LoadRelated(&house, "Area")
			//o.LoadRelated(&house, "User")
			//o.LoadRelated(&house, "Images")
			//o.LoadRelated(&house, "Facilities")
			//用下面方法查到的部分房子信息追加到respData数组中
			respData=append(respData,house.To_house_info())
		}
	}
```

解析房子需要再写一个方法。获取房源的部分信息

在models.go里创建一个方法

```go
func (this *House) To_house_info() interface{} {
   house_info := map[string]interface{}{
      "house_id":    this.Id,
      "title":       this.Title,
      "price":       this.Price,
      "area_name":   this.Area.Name,
      "img_url":     utils.AddDomain2Url(this.Index_image_url),
      "room_count":  this.Room_count,
      "order_count": this.Order_count,
      "address":     this.Address,
      "user_avatar": utils.AddDomain2Url(this.User.Avatar_url),
      "ctime":       this.Ctime.Format("2006-01-02 15:04:05"),
   }

   return house_info
}
```

现在实现把查到的信息写到缓存中

```go
//先从缓存中获取房屋数据,将缓存数据返回前端即可
	//连接redis需要的参数信息
	redis_config_map:=map[string]string{
		"key":"lovehome",
		"conn":utils.G_redis_addr+":"+utils.G_redis_port,
		"dbNum":utils.G_redis_dbnum,
	}
	//把参数信息转成json格式
	redis_config,_:=json.Marshal(redis_config_map)
	//连接redis
	cache_conn,err:=cache.NewCache("redis",string(redis_config))
	if err!=nil{
		resp["errno"]=models.RECODE_REQERR
		resp["errmsg"]=models.RecodeText(models.RECODE_REQERR)
		return
	}
	//设置key
	house_page_key:="home_page_data"
	//上传房源数据到指定key中
	house_page_value:=cache_conn.Get(house_page_key)
	//返回给前端json数据
	if house_page_value!=nil{
		beego.Debug("======= get house page info  from CACHE!!! ========")
		json.Unmarshal(house_page_value.([]byte),&respData)
		resp["data"]=respData
		return
	}
```

接下来，我们将查到的数据存到redis中

```
//将data存入缓存中
house_page_value,_=json.Marshal(respData)
cache_conn.Put(house_page_key,house_page_value,3600*time.Second)
```

最后返回json给前端

```
//返回前端data
resp["data"]=respData
return
```

附上完整代码

```go
//请求首页房源
func (this *HouseController) GetHouseIndex() {
   resp:=make(map[string]interface{})
   resp["errno"]=models.RECODE_OK
   resp["errmsg"]=models.RecodeText(models.RECODE_OK)
   defer this.RetData(resp)
   var respData []interface{}
   beego.Debug("Index Houses....")

   //1 从缓存服务器中请求 "home_page_data" 字段,如果有值就直接返回
   //先从缓存中获取房屋数据,将缓存数据返回前端即可
   //连接redis需要的参数信息
   redis_config_map:=map[string]string{
      "key":"lovehome",
      "conn":utils.G_redis_addr+":"+utils.G_redis_port,
      "dbNum":utils.G_redis_dbnum,
   }
   //把参数信息转成json格式
   redis_config,_:=json.Marshal(redis_config_map)
   //连接redis
   cache_conn,err:=cache.NewCache("redis",string(redis_config))
   if err!=nil{
      resp["errno"]=models.RECODE_REQERR
      resp["errmsg"]=models.RecodeText(models.RECODE_REQERR)
      return
   }
   //设置key
   house_page_key:="home_page_data"
   //上传房源数据到指定key中
   house_page_value:=cache_conn.Get(house_page_key)
   //返回给前端json数据
   if house_page_value!=nil{
      beego.Debug("======= get house page info  from CACHE!!! ========")
      json.Unmarshal(house_page_value.([]byte),&respData)
      resp["data"]=respData
      return
   }

   //2 如果缓存没有,需要从数据库中查询到房屋列表
   //取出house对象
   houses:=[]models.House{}
   o:=orm.NewOrm()
   //查询数据库中所有房子信息
   if _,err:=o.QueryTable("house").Limit(models.HOME_PAGE_MAX_HOUSES).All(&houses);err==nil{
      //循环遍历这些房子及关联表查询
      for _,house:=range houses{
         //o.LoadRelated(&house, "Area")
         //o.LoadRelated(&house, "User")
         //o.LoadRelated(&house, "Images")
         //o.LoadRelated(&house, "Facilities")
         //用下面方法查到的部分房子信息追加到respData数组中
         respData=append(respData,house.To_house_info())
      }
   }
   //将data存入缓存中
   house_page_value,_=json.Marshal(respData)
   cache_conn.Put(house_page_key,house_page_value,3600*time.Second)

   //返回前端data
   resp["data"]=respData
   return
}
```

## 1.4 请求房屋搜索信息

看一下前端需要的数据，这个功能不难写

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180626/df9IE4kH1g.png?imageslim)
![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180626/khiJmBjcg6.png?imageslim)
![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180626/gLJhci1cHd.png?imageslim)

业务流程图

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180626/IacJ4IjGLc.png?imageslim)



业务流程分析

1.获取用户发来的参数，aid,sd,ed,sk,p

2.检验开始时间一定要早于结束时间

3.判断p的合法性，一定要大于0的整数

4.尝试从缓存中获取数据，返回查询结果json

5.如果缓存中没有数据，从数据库中查询

（此处过于复杂，可以暂时以发布时间顺序查询）

6.将查询条件存储到缓存 

7.返回查询结果json数据给前端

先加一条路由。这个地接在post:PostHouseData那个路由后面加就行了,因为和发布房屋信息用的请求地址都一样

get:GetHouseSearchData

```
	/*
	发布房源信息post:PostHouseData
		1. Request URL: http://localhost:8899/api/v1.0/houses
		2. Request Method: POST
	获取用户搜索房源信息get:GetHouseSearchData
		Request URL: http://10.0.151.242:9999/api/v1.0/houses?aid=1&sd=2018-06-27&ed=2018-06-28&sk=new&p=1
		Request Method: GET
	*/
	beego.Router("/api/v1.0/houses", &controllers.HouseController{},"post:PostHouseData;get:GetHouseSearchData")
```

再写一个框架

```
func (this *HouseController) GetHouseSearchData()  {
   resp:=make(map[string]interface{})
   resp["errno"]=models.RECODE_OK
   resp["errmsg"]=models.RecodeText(models.RECODE_OK)
   defer this.RetData(resp)
   //1.获取用户发来的参数，aid,sd,ed,sk,p
   
   //2.检验开始时间一定要早于结束时间
   
   //3.判断p的合法性，一定要大于0的整数
   
   //4.尝试从缓存中获取数据，返回查询结果json
   
   //5.如果缓存中没有数据，从数据库中查询
   
   //（此处过于复杂，可以暂时以发布时间顺序查询）
   
   //6.将查询条件存储到缓存
   
   //7.返回查询结果json数据给前端

}
```

开始按上面流程写代码

//1.获取用户发来的参数，aid,sd,ed,sk,p

```
var aid int
this.Ctx.Input.Bind(&aid,"aid")
var sd string
this.Ctx.Input.Bind(&sd,"sd")
var ed string
this.Ctx.Input.Bind(&ed,"ed")
var sk string
this.Ctx.Input.Bind(&sk,"sk")
var page int
this.Ctx.Input.Bind(&page,"p"
```

   //2.检验开始时间一定要早于结束时间

```
//将日期转成指定格式
	start_time,_:=time.Parse("2006-01-02 15:04:05",sd+" 00:00:00")
	end_time,_:=time.Parse("2006-01-02 15:04:05",ed+" 00:00:00")
	if end_time.Before(start_time){ //如果end在start之前,返回错误信息
		resp["errno"]=models.RECODE_REQERR
		resp["errmsg"]="结束时间必须在开始时间之前"
		return
	}
```

   //3.判断p的合法性，一定要大于0的整数

```
if page<=0{
		resp["errno"]=models.RECODE_REQERR
		resp["errmsg"]="页数不能小于或等于0"
		return
	}
```

   //4.尝试从缓存中获取数据，返回查询结果json

```go
//定义一个key,注意这个存入redis中的key值拼接字符串，一定要用strconv.Itoa()转换，不要用string(),否则会出现\x01的效果,读取不了
	house_search_key:="house_search_"+strconv.Itoa(aid)
	//配置redis连接信息
	redis_config_map:=map[string]string{
		"key":"lovehome",
		"conn":utils.G_redis_addr+":"+utils.G_redis_port,
		"dbNum":utils.G_redis_dbnum,
	}
	//转成json
	redis_config,_:=json.Marshal(redis_config_map)
	//连接redis
	cache_conn, err := cache.NewCache("redis", string(redis_config))
	if err!=nil{
		resp["errno"]=models.RECODE_REQERR
		resp["errmsg"]=models.RecodeText(models.RECODE_REQERR)
		return
	}
	//从redis中拿到数据
	house_search_info:=cache_conn.Get(house_search_key)

	if house_search_info!=nil{
		beego.Debug("======= get house_search_info  from CACHE!!! ========")
		//存解码后的数据
		house_info:=[]map[string]interface{}{}
		//解码json数据
		json.Unmarshal(house_search_info.([]byte),&house_info)
		//把解码后的数据打包成json传给前端
		respData["houses"]=house_info
		respData["total_page"]=10
		respData["current_page"]=1
		resp["data"]=respData
		return
	}
```

   //5.如果缓存中没有数据，从数据库中查询

   //（此处过于复杂，可以暂时以发布时间顺序查询）

```go
//指定查询的表
	houses:=[]models.House{}
	o:=orm.NewOrm()
	//查询house表
	qs:=o.QueryTable("house")
	//查询指定城区的所有房源，按发布时间降序排列
	num,err:=qs.Filter("area_id",aid).OrderBy("-ctime").All(&houses)
	if err!=nil{
		resp["errno"]=models.RECODE_DBERR
		resp["errmsg"]=models.RecodeText(models.RECODE_DBERR)
		return
	}
	//求出所有分页
	total_page:=int(num)/models.HOUSE_LIST_PAGE_CAPACITY+1
	//起始页数
	house_page:=1
	//用来存遍历到的房屋数据
	var house_list []interface{}
	//遍历出上面查到的房屋数据，加到数组house_list中
	for _,house:=range houses  {
		o.LoadRelated(&house, "Area")
		o.LoadRelated(&house, "User")
		o.LoadRelated(&house, "Images")
		o.LoadRelated(&house, "Facilities")
		house_list=append(house_list,house.To_house_info())
	}
	//拿到了houst_list数据
	fmt.Println("========house_list======",house_list)
```

   //6.将查询条件存储到缓存

```go
houst_search_list,_:=json.Marshal(house_list)
cache_conn.Put(house_search_key,houst_search_list,3600*time.Second)
```

   //7.返回查询结果json数据给前端

```go
respData["houses"]=house_list
respData["total_page"]=total_page
respData["current_page"]=house_page
resp["data"]=respData
return
```

## 1.5 发布订单

我们现在开始写发布订单业务，需要先写这部分，因为只有有订单信息才能用后面的查看订单功能。

我们预定房间试一下，

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180625/J0lcibi4IL.png?imageslim)

发现请求报红

请求的地址：

1. Request URL: http://10.0.151.242:8899/api/v1.0/orders

2. Request Method: POST

发到后端的信息：
```
end_date:"2018-06-30"
house_id:"1"
start_date:"2018-06-29"
```

看一下前端需要数据

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180625/5JC2El7leK.png?imageslim)
![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180625/heD5L959gL.png?imageslim)
![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180625/FJkafH8E6L.png?imageslim)
业务逻辑图

**![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180625/LbIgBB4km1.png?imageslim)**

操作流程：

1.根据session得到用户id

2.得到用户请求的json数据，检测合法性，不合法就返回错误json数据

3.确定退房时间end_date必须在订房时间start_date之后

可以用一个函数

```
a1:=time.Now()
a2:=time.Now()
//a1的时候在a2之前吗，返回bool
a1.Before(a2)
```

3.得到一共入住的天数

4.根据order_id获取关联的房源信息

5.确保当前的user_id不是房源信息所关联的user_id（就是说房东不能自己预定自己房子）

6.确保用户选择的房屋未被预定，日期没有冲突，如果已经被人预定返回错误信息

（此处逻辑过于复杂，可以先不判断）

7.封装完整的order订单信息

8.将订单信息写入表中

9.返回order_id的json给前端

然后去添加一条路由，专门处理发布订单数据

```go
/*
提交订单
   Request URL: http://localhost:8899/api/v1.0/orders
   Request Method: POST
*/
beego.Router("/api/v1.0/orders", &controllers.OrderController{},"post:PostOrderHouseData")
```

现在开始实现这个功能，先创建一个结构体，用来存放前端发来的订单数据

```go
type OrderRequest struct {
   House_id   string `json:"house_id"`   //下单的房源id
   Start_date string `json:"start_date"` //订单开始时间
   End_date   string `json:"end_date"`   //订单结束时间
}
```

再在order.go里写这个方法，还是先写框架

```go
func (this *OrderController) PostOrderHouseData()  {
   resp:=make(map[string]interface{})
   resp["errno"]=models.RECODE_OK
   resp["errmsg"]=models.RecodeText(models.RECODE_OK)
   defer this.RetData(resp)
   //1.根据session得到用户id

   //2.得到用户请求的json数据，检测合法性，不合法就返回错误json数据

   //3.确定退房时间end_date必须在订房时间start_date之后

   //可以用一个函数

   /*
   a1:=time.Now()
   a2:=time.Now()
   a1的时候在a2之前吗，返回bool
   a1.Before(a2)
   */

   //3.得到一共入住的天数

   //4.根据order_id获取关联的房源信息

   //5.确保当前的user_id不是房源信息所关联的user_id（就是说房东不能自己预定自己房子）

   //6.确保用户选择的房屋未被预定，日期没有冲突，如果已经被人预定返回错误信息

   //（此处逻辑过于复杂，可以先不判断）

   //7.封装完整的order订单信息

   //8.将订单信息写入表中
   
   //9.返回order_id的json给前端

}
```

好了。我们一步一步实现功能

1.根据session得到用户id

```
user_id:=this.GetSession("user_id")
```

2.得到用户请求的json数据，检测合法性，不合法就返回错误json数据

```go
var req OrderRequest
if err:=json.Unmarshal(this.Ctx.Input.RequestBody,&req);err!=nil{
	resp["errno"]=models.RECODE_REQERR
	resp["errmsg"]=models.RecodeText(models.RECODE_REQERR)
	return
}
fmt.Printf("req = %+v\n", req)
//用户请求参数做合法判断
if req.House_id==""||req.Start_date==""||req.End_date==""{
	resp["errno"]=models.RECODE_REQERR
	resp["errmsg"]="请求参数为空"
	return
}
```

3.确定退房时间end_date必须在订房时间start_date之后

```
可以用一个函数
a1:=time.Now()
a2:=time.Now()
//a1的时候在a2之前吗，返回bool
a1.Before(a2)
```

```
//格式化日期时间
start_date_time,_:=time.Parse("2006-01-02 15:04:05",req.Start_date+" 00:00:00")
end_date_time,_:=time.Parse("2006-01-02 15:04:05",req.End_date+" 00:00:00")
//确保end_date 在 start_date之后
if end_date_time.Before(start_date_time){ //如果end在start之前,返回错误信息
   resp["errno"]=models.RECODE_REQERR
   resp["errmsg"]="结束时间在开始时间之前"
   return
}
fmt.Printf("start_date_time = %v,end_date_time = %v",start_date_time,end_date_time)
```

3.得到一共入住的天数

```
//意思就是获取end_date_time距离start_date_time共几天
days:=end_date_time.Sub(start_date_time).Hours()/24+1
fmt.Printf("days = %f\n",days)
```

4.根据order_id获取关联的房源信息

```go
house_id,_:=strconv.Atoi(req.House_id)
//操作house表，where house_id
house:=models.House{Id:house_id}
o:=orm.NewOrm()
//读取house表中的当前房源信息
if err:=o.Read(&house);err!=nil{
   resp["errno"]=models.RECODE_NODATA
   resp["errmsg"]=models.RecodeText(models.RECODE_NODATA)
   return
}
//将house表和User表关联查询
o.LoadRelated(&house,"User")
```

5.确保当前的user_id不是房源信息所关联的user_id（就是说房东不能自己预定自己房子）

这个肯定要先去house表查看一下house.User.Id是否和当前用户user_id相等 ，相等就是房东。

```go
//房东不能预定自己的房子
if user_id==house.User.Id{
   resp["errno"]=models.RECODE_ROLEERR
   resp["errmsg"]=models.RecodeText(models.RECODE_ROLEERR)
   return
}
```

6.确保用户选择的房屋未被预定，日期没有冲突，如果已经被人预定返回错误信息

（此处逻辑过于复杂，可以先不判断）

7.封装完整的order订单信息

```go
//给orderHouse结构体数据
//这里获取user,house结构体，才能从这两个表中取数据，前面已经关联好数据了，所以这两个结构体里是有数据的
amount:=days * float64(house.Price) //天数 *钱数,返回订单总金额

order:=models.OrderHouse{} //操作房源订单表
user:=models.User{Id:user_id.(int)} //操作User数据

order.House=&house //order获取到house数据
order.User=&user //order获得user数据
order.Begin_data=start_date_time //起始时间
order.End_data=end_date_time //结束时间
order.Days=int(days) //总天数
order.House_price=house.Price //房间间价
order.Amount=int(amount) //订单总金额
order.Status=models.ORDER_STATUS_WAIT_ACCEPT //订单状态
fmt.Printf("order = %+v\n",order)
```

8.将订单信息写入表中

```go
if _,err:=o.Insert(&order);err!=nil{
   resp["errno"]=models.RECODE_DBERR
   resp["errmsg"]=models.RecodeText(models.RECODE_DBERR)
   return
}
```

9.返回order_id的json给前端

```go
this.SetSession("user_id",user_id)
respData:=make(map[string]interface{})
respData["order_id"]=order.Id
resp["data"]=respData
return
```

写好了。完整代码如下。

测试了一下，可以成功发布订单

好了。我们测试一下看看能不能预定，可以预定成功。

看一下数据库

![1529934896676](C:\Users\Administrator\AppData\Local\Temp\1529934896676.png)

订单数据插入成功。

下面我们实现房东和租客查看订单信息功能

## 1.6请求查看房东/租客订单信息

然后开始写租客订单，房东订单信息

role=custom为租客查看订单信息

role=landlord为房东查看被预定订单信息

这个请求类似于?user=wyf&password=123456

我们会用到beego自带的一个方法GetString(key string) string,就能获取到user,wyf等信息。

我的订单就相当于我租房子，我是租客

客户订单相当于我有房子要租，我是房东，别人租我的房子的订单信息。

custom，租客订单看一下在哪里

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180625/GG5jjc83Fd.png?imageslim)

请求的地址

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180625/D7E41i7IcE.png?imageslim)

订单的请求地址和方法，custom是消费者的意思

1. Request URL: http://10.0.151.242:8899/api/v1.0/user/orders?role=custom
2. Request Method: GET

再看一下房东的订单在哪里

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180625/laH9l0B9Lj.png?imageslim)

点这个客户订单，就是房东的订单信息

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180625/b6CBjbceLl.png?imageslim)

看一下请求数据和方法。landlord的意思就是房东

1. Request URL: http://10.0.151.242:8899/api/v1.0/user/orders?role=landlord
2. Request Method: GET

前端需要数据

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180625/H79eJi70ha.png?imageslim)
![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180626/6LjCjDjgK3.png?imageslim)
![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180625/E9m4Fd4HCD.png?imageslim)
![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180625/2GD91FK644.png?imageslim)
前端的json数据需要的不多，只需要订单数据和房子的部分信息

现在看一下业务流程图

![1529926025105](C:\Users\Administrator\AppData\Local\Temp\1529926025105.png)

业务设计流程：

1.根据session获取当前用户user_id

2.根据url获得当前用户角色custom为租客，landlord为房东

这里可以用GetString(key string)string即可获取到角色

​	如果role为空，则返回json错误信息

查询house表：

​	如果是房东，找到自己都有哪些房子在发布，得到house_id集合,然后接下来查询房屋订单表，找到订单中关联的房屋id在house_id房东集合的全部的订单

​	如果是租客，查询房屋订单表找到自己发布的全部订单

3.返回正确的json



我们来先来做租客的订单怎么实现。

先加一条路由。

```
/*
   我的订单，租客订单
   1. Request URL: http://10.0.151.242:8899/api/v1.0/user/orders?role=custom
   2. Request Method: GET
   */
beego.Router("/api/v1.0/user/orders", &controllers.OrderController{},"get:GetOrderData")
```

再创建一个新的go文件，用来处理order信息controllers里的order.go

先写一个框架

```
package controllers

import "github.com/astaxie/beego"

type OrderController struct {
   beego.Controller
}

func (this *OrderController) RetData(resp map[string]interface{})  {
   this.Data["json"] = resp
   this.ServeJSON()
}

func (this *OrderController) GetOrderData() {
   	resp:=make(map[string]interface{})
	resp["errno"]=models.RECODE_OK
	resp["errmsg"]=models.RecodeText(models.RECODE_OK)
	defer this.RetData(resp)
}
```

  好了。开始写代码

1.根据session获取当前用户user_id

```
user_id:=this.GetSession("user_id").(int)
```

2.根据url获得当前用户角色custom为租客，landlord为房东

这里可以用GetString(key string)string即可获取到角色

​	如果role为空，则返回json错误信息

```
role:=this.GetString("role")

//如果role为空，则返回json错误信息
if role==""{
   resp["errno"]=models.RECODE_ROLEERR
   resp["errmsg"]=models.RecodeText(models.RECODE_ROLEERR)
   return
}
```

查询house表：

​	如果是房东，找到自己都有哪些房子在发布，得到house_id集合,然后接下来查询房屋订单表，找到订单中关联的房屋id在house_id房东集合的全部的订单

​	如果是租客，查询房屋订单表找到自己发布的全部订单

```go
if role=="landlord"{
   beego.Info("我是房东")
   landLordHouses:=[]models.House{}
   //把房东的房源信息全都查出来
   o.QueryTable("house").Filter("user__id",user_id).All(&landLordHouses)
   //int数组专门存房源id
   housesIds:=[]int{}
   //遍历所以房源信息
   for _,house:=range landLordHouses{
      //把房子id追加到houseIds数组中，拿到houseIds数组
      housesIds=append(housesIds,house.Id)
   }
   //在订单表中找到房东house_id为自己房源的id的所有房子
   //house__id__in相当于select  *  from  order_house  where  house.id  in('1','2','3');
   //意思就是查询house.id=1，2，3的都查出来。
   //切记，Filter里一定要用双下划线.
   o.QueryTable("order_house").Filter("house__id__in",housesIds).OrderBy("-ctime").All(&orders)
}else{
   //如果是租客，查询房屋订单表找到自己发布的全部订单
   beego.Info("我是租客")
   o.QueryTable("order_house").Filter("user__id",user_id).OrderBy("-ctime").All(&orders)
}
//关联house和user表，查询出所有订单数据，追加到order_list数组中，需要返回给前端的数据
for _,order:=range orders{
	o.LoadRelated(&order,"House")
	o.LoadRelated(&order,"User")
	order_list=append(order_list,order.To_order_info())
}
```

再说一下orm高级查询的Filter的其它用法

```
qs.Filter("id", 1) // WHERE id = 1
qs.Filter("profile__age", 18) // WHERE profile.age = 18
qs.Filter("Profile__Age", 18) // 使用字段名和 Field 名都是允许的
qs.Filter("profile__age", 18) // WHERE profile.age = 18
qs.Filter("profile__age__gt", 18) // WHERE profile.age > 18
qs.Filter("profile__age__gte", 18) // WHERE profile.age >= 18
qs.Filter("profile__age__in", 18, 20) // WHERE profile.age IN (18, 20)

qs.Filter("profile__age__in", 18, 20).Exclude("profile__lt", 1000)
// WHERE profile.age IN (18, 20) AND NOT profile_id < 1000
```



3.返回正确的json

```go
respData:=make(map[string]interface{})
respData["orders"]=order_list
resp["data"]=respData
```

好了。写完了。去测试一下。

先登录一下个人帐号，去订一个房看看。

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180626/BH9lGAEf59.png?imageslim)

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180626/jfG2AF47Ig.png?imageslim)

预定成功

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180626/E8h5lIIK5h.png?imageslim)

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180626/J2gg267m9D.png?imageslim)

返回的json数据都是正确的。

再看一下房东的数据，登录房东帐号222

发现有订单数据

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180626/I0jb2fhDkc.png?imageslim)

可以接单，可以拒单。

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180626/B92E7A4g9e.png?imageslim)

json数据也是正确的。

## 1.7 房东同意/拒绝订单

好了。写完了。现在房东能看到租客的订单信息，并出现两个按钮，接单和拒单，但是现在用不了。报红。

我们现在去实现一下。先测试一下。

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180626/5bkm9JgcH0.png?imageslim)

出现请求地址：

1. Request URL: http://10.0.151.242:8899/api/v1.0/orders/4/status
2. Request Method: PUT

发现前端提交了一条数据 action:"accept" ，我们只需要获取这个值就能判断了

接单是：{action: "accept"} 

拒单是：{action: "reject", reason: "不接"} 

看一下前端需要的数据

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180626/7FecK3cmAE.png?imageslim)
![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180626/43c3K0hHB6.png?imageslim)
  业务流程图

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180626/fdg4iJ6add.png?imageslim)

先写一下业务流程

1.根据session拿到user_id

2.通过当前url参数得到当前订单id

3.解析客户端请求的json数据，得到action数据

4.检验action是否合法，不合法，返回json错误信息

5.查找订单表，找到该订单并确定当前的订单状态是WAIT_ACCEPT

6.检验该订单的user_id是否是当前用户的user_id

7.判断action

如果action为accept(接单)，更换该订单status为WAIT_COMMENT等待用户评价

如果action为reject(拒单),更换订单status为REJECT，然后从url参数获取reason参数字段 ，将reason字段的value添加到order的评价comment字段中

上面都完成后，更新该订单数据到数据库中。o.Update()

8.返回正确json给前端

好了。先添加一条路由

```go
/*
   房东处理订单
   1. Request URL: http://10.0.151.242:8899/api/v1.0/orders/4/status
   2. Request Method: PUT
   */
beego.Router("/api/v1.0/orders/:id/status", &controllers.OrderController{},"put:OrderStatus")
```

还是先写一个框架。和以前的都一样。

```go
func (this *OrderController) OrderStatus()  {
	resp:=make(map[string]interface{})
	resp["errno"]=models.RECODE_OK
	resp["errmsg"]=models.RecodeText(models.RECODE_OK)
	defer this.RetData(resp)
	//1.根据session拿到user_id

	//2.通过当前url参数得到当前订单id

	//3.解析客户端请求的json数据，得到action数据

	//4.检验action是否合法，不合法，返回json错误信息

	//5.查找订单表，找到该订单并确定当前的订单状态是WAIT_ACCEPT

	//6.检验该订单的user_id是否是当前用户的user_id

	//7.判断action

	//如果action为accept(接单)，更换该订单status为WAIT_COMMENT等待用户评价

	//如果action为reject(拒单),更换订单status为REJECT，然后从url参数获取reason参数字段 ，将reason字段的value添加到order的评价comment字段中

	//上面都完成后，更新该订单数据到数据库中。o.Update()

	//8.返回正确json给前端

}
```

1.根据session拿到user_id

```
user_id:=this.GetSession("user_id")
```

2.通过当前url参数得到当前订单id

```
order_id:=this.Ctx.Input.Param(":id")
```

3.解析客户端请求的json数据，得到action数据

```go
/用来存获取到的请求数据action,reason
var req map[string]interface{}
if err:=json.Unmarshal(this.Ctx.Input.RequestBody,&req);err!=nil{
   resp["errno"]=models.RECODE_REQERR
   resp["errmsg"]=models.RecodeText(models.RECODE_REQERR)
   return
}
```

4.检验action是否合法，不合法，返回json错误信息

```go
action:=req["action"]
if action!="accept" && action!="reject"{
   resp["errno"]=models.RECODE_REQERR
   resp["errmsg"]=models.RecodeText(models.RECODE_REQERR)
   return
}
```

5.查找订单表，找到该订单并确定当前的订单状态是WAIT_ACCEPT

```go
o:=orm.NewOrm()
order:=models.OrderHouse{}
//查到订单状态数据是否为待接单，如果是就查询出这个房源的订单信息
if err:=o.QueryTable("order_house").Filter("id",order_id).Filter("status",models.ORDER_STATUS_WAIT_ACCEPT).One(&order);err!=nil{
   resp["errno"]=models.RECODE_DBERR
   resp["errmsg"]=models.RecodeText(models.RECODE_DBERR)
   return
}
```

6.检验该订单的user_id是否是当前用户的user_id

```go
/*
把order表和house表做关联，才能检验订单,必须做关联，不做关联查询不到数据，会报错
[C] [asm_amd64.s:573] Handler crashed with error runtime error: invalid memory address or nil pointer dereference
解释：程序在运行时候出错：内存地址无效，空指针被回收
*/
if _,err:=o.LoadRelated(&order,"House");err!=nil{
   resp["errno"]=models.RECODE_DATAERR
   resp["errmsg"]=models.RecodeText(models.RECODE_DATAERR)
   return
}
house:=order.House
fmt.Printf("house = %+v\n", house)
fmt.Printf("house.user_id = %d\n", house.User.Id)
if house.User.Id!=user_id{
   resp["errno"]=models.RECODE_DATAERR
   resp["errmsg"]="订单用户不匹配,操作无效"
   return
}
```

重要的。o.LoadRelated(&order,"House")

需要把house数据获取到，可以通过关联查询。

o.LoadRelated(&order,"House")这个意思是查询order结构体内的house结构体内的全部数据，包括关联数据.

这部分我们看一下关联的结构

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180626/9Ib6Jj6gbg.png?imageslim)

以上图片可以看到。order表下关联了User和House。

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180626/a43ed7ebBD.png?imageslim)

定位到House表中，关联了User.

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180626/4K2HD0g2m0.png?imageslim)

然后user表里会有Id

所有我们关联后，其实就相当于得到了house和user表里的数据

```
house:=order.House
```

```
house.User.Id
```

并能调用到order.house.user.Id字段 。



7.判断action

如果action为accept(接单)，更换该订单status为WAIT_COMMENT等待用户评价

如果action为reject(拒单),更换订单status为REJECT，然后从url参数获取reason参数字段 ，将reason字段的value添加到order的评价comment字段中

```go
if action=="accept"{
   //如果action为accept(接单)，更换该订单status为WAIT_COMMENT等待用户评价
   order.Status=models.ORDER_STATUS_WAIT_COMMENT
   beego.Debug("action = accpet!")
   beego.Debug("order.Status = ",order.Status)
}else if action=="reject"{
   //如果action为reject(拒单),更换订单status为REJECT，然后从url参数获取reason参数字段 ，将reason字段的value添加到order的评价comment字段中
   order.Status=models.ORDER_STATUS_REJECTED
   reason:=req["reason"]
   order.Comment=reason.(string)
   beego.Debug("action = reject!, reason is ", reason)
   beego.Debug("order.Comment = ",order.Comment)
}
```

上面都完成后，更新该订单数据到数据库中。o.Update()

```go
if _,err:=o.Update(&order);err!=nil{
   resp["errno"]=models.RECODE_DBERR
   resp["errmsg"]=models.RecodeText(models.RECODE_DBERR)
   return
}
```

8.返回正确json给前端

第一行已经返回了

附上完整代码

```go
//房东接单/拒单处理
func (this *OrderController) OrderStatus()  {
   resp:=make(map[string]interface{})
   resp["errno"]=models.RECODE_OK
   resp["errmsg"]=models.RecodeText(models.RECODE_OK)
   defer this.RetData(resp)
   //1.根据session拿到user_id
   user_id:=this.GetSession("user_id")
   //2.通过当前url参数得到当前订单id
   order_id:=this.Ctx.Input.Param(":id")
   //3.解析客户端请求的json数据，得到action数据
   //用来存获取到的请求数据action,reason
   var req map[string]interface{}
   if err:=json.Unmarshal(this.Ctx.Input.RequestBody,&req);err!=nil{
      resp["errno"]=models.RECODE_REQERR
      resp["errmsg"]=models.RecodeText(models.RECODE_REQERR)
      return
   }
   //4.检验action是否合法，不合法，返回json错误信息
   action:=req["action"]
   if action!="accept" && action!="reject"{
      resp["errno"]=models.RECODE_REQERR
      resp["errmsg"]=models.RecodeText(models.RECODE_REQERR)
      return
   }
   //5.查找订单表，找到该订单并确定当前的订单状态是WAIT_ACCEPT
   o:=orm.NewOrm()
   order:=models.OrderHouse{}
   //查到订单状态数据是否为待接单，如果是就查询出这个房源的订单信息
   if err:=o.QueryTable("order_house").Filter("id",order_id).Filter("status",models.ORDER_STATUS_WAIT_ACCEPT).One(&order);err!=nil{
      resp["errno"]=models.RECODE_DBERR
      resp["errmsg"]=models.RecodeText(models.RECODE_DBERR)
      return
   }

   //6.检验该订单的user_id是否是当前用户的user_id
   /*
   把order表和house表做关联，才能检验订单,必须做关联，不做关联查询不到数据，会报错
   [C] [asm_amd64.s:573] Handler crashed with error runtime error: invalid memory address or nil pointer dereference
   解释：程序在运行时候出错：内存地址无效，空指针被回收
   */
   if _,err:=o.LoadRelated(&order,"House");err!=nil{
      resp["errno"]=models.RECODE_DATAERR
      resp["errmsg"]=models.RecodeText(models.RECODE_DATAERR)
      return
   }
   house:=order.House
   fmt.Printf("house = %+v\n", house)
   fmt.Printf("house.user_id = %d\n", house.User.Id)
   if house.User.Id!=user_id{
      resp["errno"]=models.RECODE_DATAERR
      resp["errmsg"]="订单用户不匹配,操作无效"
      return
   }

   //7.判断action
   if action=="accept"{
      //如果action为accept(接单)，更换该订单status为WAIT_COMMENT等待用户评价
      order.Status=models.ORDER_STATUS_WAIT_COMMENT
      beego.Debug("action = accpet!")
      beego.Debug("order.Status = ",order.Status)
   }else if action=="reject"{
      //如果action为reject(拒单),更换订单status为REJECT，然后从url参数获取reason参数字段 ，将reason字段的value添加到order的评价comment字段中
      order.Status=models.ORDER_STATUS_REJECTED
      reason:=req["reason"]
      order.Comment=reason.(string)
      beego.Debug("action = reject!, reason is ", reason)
      beego.Debug("order.Comment = ",order.Comment)
   }

   //上面都完成后，更新该订单数据到数据库中。o.Update()
   if _,err:=o.Update(&order);err!=nil{
      resp["errno"]=models.RECODE_DBERR
      resp["errmsg"]=models.RecodeText(models.RECODE_DBERR)
      return
   }
   //8.返回正确json给前端
   //第一行已经返回了
}
```

好了。我们测试一下可不可以用

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180626/dF8Iekge9L.png?imageslim)

现在假如说有一个客户订了2间房，我们现在试一下接单。

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180626/Diid80ebdl.png?imageslim)

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180626/g3426A4FkJ.png?imageslim)

编号6的变为已接单了，已接单这是前端显示的，不是我们给的状态，刷新一下

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180626/ek7cL6dcBk.png?imageslim)



订单状态又变成待评价了。这是我们设定的，说明成功了

看一下json状态

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180626/lDfdcia5CB.png?imageslim)

status已经是WAIT_COMMENT，待评价状态。

再把订单5拒单试试。

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180626/ig9m8DFA87.png?imageslim)

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180626/GidELgcdHj.png?imageslim)

订单5显示已拒单，看一下json

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180626/hbb2AA2fcI.png?imageslim)

也是没有问题的。订单状态status:REJECTED,拒单

拒单原因 comment:"无房"

再去客户那边看一下这两单的状态。

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180626/3AF26gg5JF.png?imageslim)

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180626/chaGhghiF3.png?imageslim)

上面是订单6的信息，房东接单后，订单状态变为待评价，然后发表评价按钮功能也可以用了。

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180626/eDb80j825a.png?imageslim)

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180626/bkADAkgjb5.png?imageslim)

订单5是拒单的，status:"REJECTED",comment:"无房"

好了。没有问题。功能都完整可用。现在用户可以评论了，我们去实现用户评价订单功能

## 1.8 用户评价订单信息

这个就比较简单了。

看一下前端需要的数据

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180626/42F5eHJfie.png?imageslim)
![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180626/C86G1lkdec.png?imageslim)

先来看一下评价是需要什么请求

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180626/75LD23AHdD.png?imageslim)

1. Request URL: http://10.0.151.242:8899/api/v1.0/orders/6/comment
2. Request Method: PUT

前端发到后端的json数据、

```
{order_id: "6", comment: "不好"}
```



现在开始写吧。

先创建一条路由，专门用来处理发表评价

```go
/*
用户发送订单评价信息
   1. Request URL: http://10.0.151.242:8899/api/v1.0/orders/6/comment
   2. Request Method: PUT
*/
beego.Router("/api/v1.0/orders/:id/comment", &controllers.OrderController{},"put:OrderComment")
```

再写一个框架，这个是必备的哦

```go
func (this *OrderController) OrderComment()  {
   resp:=make(map[string]interface{})
   resp["errno"]=models.RECODE_OK
   resp["errmsg"]=models.RecodeText(models.RECODE_OK)
   defer this.RetData(resp)

}
```

好了。我们开始实现代码，这个流程有点复杂 

//1.通过session获得用户id

```
user_id:=this.GetSession("user_id").(int)
```

//2.通过请求url获取order_id.

```
order_id:=this.Ctx.Input.Param(":id")
```

//3.获取前端发过来的请求参数的value

```go
var req map[string]interface{}
if err:=json.Unmarshal(this.Ctx.Input.RequestBody,&req);err!=nil{
   resp["errno"]=models.RECODE_REQERR
   resp["errmsg"]=models.RecodeText(models.RECODE_REQERR)
   return
}
```

//4.检验评价信息是否合法，确保不为空

```go
comment:=req["comment"].(string)
if comment==""{
   resp["errno"]=models.RECODE_PARAMERR
   resp["errmsg"]=models.RecodeText(models.RECODE_PARAMERR)
   return
}
```

//5.查询数据库，订单必须存在，订单状态必须为WAI_COMMENT待评价状态。

```go
order:=models.OrderHouse{} //获取orderhouse表，把查到的数据存这里
o:=orm.NewOrm()
if err:=o.QueryTable("order_house").Filter("id",order_id).Filter("status",models.ORDER_STATUS_WAIT_COMMENT).One(&order);err!=nil{
   resp["errno"]=models.RECODE_DBERR
   resp["errmsg"]=models.RecodeText(models.RECODE_DBERR)
   return
}
```

//6.确保订单所关联的用户和该用户是同一个人

```go
// 关联查询order订单所关联的user信息
if _,err:=o.LoadRelated(&order,"User");err!=nil{
   resp["errno"]=models.RECODE_DBERR
   resp["errmsg"]=models.RecodeText(models.RECODE_DBERR)
   return
}
//如果不是本人，就报错
if user_id!=order.User.Id{
   resp["errno"]=models.RECODE_DATAERR
   resp["errmsg"]="该订单并不属于本人"
   return
}
```

//7.关联查询order订单所关联的House信息

```go
if _,err:=o.LoadRelated(&order,"House");err!=nil{
		resp["errno"]=models.RECODE_DBERR
		resp["errmsg"]=models.RecodeText(models.RECODE_DBERR)
		return
	}

//拿到order订单对应的House所有数据
house:=order.House
```

//8.更新order的status为COMPLETE,更新order的comment信息

```
order.Status=models.ORDER_STATUS_COMPLETE
order.Comment=comment
```

//9.订房成功，将房屋订单成交量+1

```
house.Order_count++
```

//10.将order和house完整数据更新到数据库中,指定只更新status,comment字段的数据

```go
//cols意思是，只更新status和comment的数据，其它字段不更新
if _,err:=o.Update(&order,"status","comment");err!=nil{
   beego.Error("update order status, comment error, err = ", err)
   resp["errno"]=models.RECODE_DBERR
   resp["errmsg"]=models.RecodeText(models.RECODE_DBERR)
   return
}
//更新house表的时候不需要指针，因为不是传的对象,上面是对象，所以需要传指针
if _,err:=o.Update(house,"order_count");err!=nil{
   beego.Error("update house order_count error, err = ", err)
   resp["errno"]=models.RECODE_DBERR
   resp["errmsg"]=models.RecodeText(models.RECODE_DBERR)
   return
}
```

//11.将house_info_[house_id]存的的redis的key删除（因为已经修改了订单数量）

```go
//设置redis配置信息

redis_config_map:=map[string]string{
   "key":"lovehome",
   "conn":utils.G_redis_addr+":"+utils.G_redis_port,
   "dbNum":utils.G_redis_dbnum,
}
//把redis信息打包成json
redis_config,_:=json.Marshal(redis_config_map)
//连接redis
cache_conn,err:=cache.NewCache("redis",string(redis_config))
if err!=nil{
   beego.Debug("connect cache error")
}
//key指定为house.Id,因为redis存的时候用的就是house.Id
house_info_key:=strconv.Itoa(house.Id)
//删除
if err:=cache_conn.Delete(house_info_key);err!=nil{
   beego.Error("delete",house_info_key,"error,err = ",err)
}
return
```

最后返回json成功信息就可以了。

好了。测试一下

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180626/mD6jhKkCcf.png?imageslim)

这条信息可以评价

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180626/Ed7BLB61l1.png?imageslim)

评价了。

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180626/hh93imd6bh.png?imageslim)

订单状态显示已完成，刷新一下

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180626/bfk1Ek4Abc.png?imageslim)

发现显示评价信息了。再看一下数据库，有没有更新状态和订单数量 

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180626/H0DfhGI37H.png?imageslim)
更新成功，再看一下house表的order_count有没有+1

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180626/DFlC9jIE01.png?imageslim)

正常+1，看一下redis中有没有删除

![mark](http://p9ug71a1p.bkt.clouddn.com/blog/180626/Ke0j53L5Ai.png?imageslim)

redis中也没有数据了。都是没问题的。







